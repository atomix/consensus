// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: atomix/multiraft/v1/fsm.proto

package v1

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Failure_Status int32

const (
	Failure_UNKNOWN        Failure_Status = 0
	Failure_ERROR          Failure_Status = 1
	Failure_CANCELED       Failure_Status = 2
	Failure_NOT_FOUND      Failure_Status = 3
	Failure_ALREADY_EXISTS Failure_Status = 4
	Failure_UNAUTHORIZED   Failure_Status = 5
	Failure_FORBIDDEN      Failure_Status = 6
	Failure_CONFLICT       Failure_Status = 7
	Failure_INVALID        Failure_Status = 8
	Failure_UNAVAILABLE    Failure_Status = 9
	Failure_NOT_SUPPORTED  Failure_Status = 10
	Failure_TIMEOUT        Failure_Status = 11
	Failure_FAULT          Failure_Status = 12
	Failure_INTERNAL       Failure_Status = 13
)

var Failure_Status_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "ERROR",
	2:  "CANCELED",
	3:  "NOT_FOUND",
	4:  "ALREADY_EXISTS",
	5:  "UNAUTHORIZED",
	6:  "FORBIDDEN",
	7:  "CONFLICT",
	8:  "INVALID",
	9:  "UNAVAILABLE",
	10: "NOT_SUPPORTED",
	11: "TIMEOUT",
	12: "FAULT",
	13: "INTERNAL",
}

var Failure_Status_value = map[string]int32{
	"UNKNOWN":        0,
	"ERROR":          1,
	"CANCELED":       2,
	"NOT_FOUND":      3,
	"ALREADY_EXISTS": 4,
	"UNAUTHORIZED":   5,
	"FORBIDDEN":      6,
	"CONFLICT":       7,
	"INVALID":        8,
	"UNAVAILABLE":    9,
	"NOT_SUPPORTED":  10,
	"TIMEOUT":        11,
	"FAULT":          12,
	"INTERNAL":       13,
}

func (x Failure_Status) String() string {
	return proto.EnumName(Failure_Status_name, int32(x))
}

func (Failure_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{23, 0}
}

type SessionSnapshot_State int32

const (
	SessionSnapshot_UNKNOWN SessionSnapshot_State = 0
	SessionSnapshot_OPEN    SessionSnapshot_State = 1
	SessionSnapshot_CLOSED  SessionSnapshot_State = 2
)

var SessionSnapshot_State_name = map[int32]string{
	0: "UNKNOWN",
	1: "OPEN",
	2: "CLOSED",
}

var SessionSnapshot_State_value = map[string]int32{
	"UNKNOWN": 0,
	"OPEN":    1,
	"CLOSED":  2,
}

func (x SessionSnapshot_State) String() string {
	return proto.EnumName(SessionSnapshot_State_name, int32(x))
}

func (SessionSnapshot_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{27, 0}
}

type SessionProposalSnapshot_Phase int32

const (
	SessionProposalSnapshot_PENDING  SessionProposalSnapshot_Phase = 0
	SessionProposalSnapshot_RUNNING  SessionProposalSnapshot_Phase = 1
	SessionProposalSnapshot_COMPLETE SessionProposalSnapshot_Phase = 2
	SessionProposalSnapshot_CANCELED SessionProposalSnapshot_Phase = 3
)

var SessionProposalSnapshot_Phase_name = map[int32]string{
	0: "PENDING",
	1: "RUNNING",
	2: "COMPLETE",
	3: "CANCELED",
}

var SessionProposalSnapshot_Phase_value = map[string]int32{
	"PENDING":  0,
	"RUNNING":  1,
	"COMPLETE": 2,
	"CANCELED": 3,
}

func (x SessionProposalSnapshot_Phase) String() string {
	return proto.EnumName(SessionProposalSnapshot_Phase_name, int32(x))
}

func (SessionProposalSnapshot_Phase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{28, 0}
}

type RaftProposal struct {
	Term        Term                       `protobuf:"varint,1,opt,name=term,proto3,casttype=Term" json:"term,omitempty"`
	SequenceNum SequenceNum                `protobuf:"varint,2,opt,name=sequence_num,json=sequenceNum,proto3,casttype=SequenceNum" json:"sequence_num,omitempty"`
	Timestamp   time.Time                  `protobuf:"bytes,3,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	Proposal    *StateMachineProposalInput `protobuf:"bytes,4,opt,name=proposal,proto3" json:"proposal,omitempty"`
}

func (m *RaftProposal) Reset()         { *m = RaftProposal{} }
func (m *RaftProposal) String() string { return proto.CompactTextString(m) }
func (*RaftProposal) ProtoMessage()    {}
func (*RaftProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{0}
}
func (m *RaftProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftProposal.Merge(m, src)
}
func (m *RaftProposal) XXX_Size() int {
	return m.Size()
}
func (m *RaftProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftProposal.DiscardUnknown(m)
}

var xxx_messageInfo_RaftProposal proto.InternalMessageInfo

func (m *RaftProposal) GetTerm() Term {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *RaftProposal) GetSequenceNum() SequenceNum {
	if m != nil {
		return m.SequenceNum
	}
	return 0
}

func (m *RaftProposal) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *RaftProposal) GetProposal() *StateMachineProposalInput {
	if m != nil {
		return m.Proposal
	}
	return nil
}

type StateMachineProposalInput struct {
	// Types that are valid to be assigned to Input:
	//	*StateMachineProposalInput_OpenSession
	//	*StateMachineProposalInput_KeepAlive
	//	*StateMachineProposalInput_CloseSession
	//	*StateMachineProposalInput_Proposal
	Input isStateMachineProposalInput_Input `protobuf_oneof:"input"`
}

func (m *StateMachineProposalInput) Reset()         { *m = StateMachineProposalInput{} }
func (m *StateMachineProposalInput) String() string { return proto.CompactTextString(m) }
func (*StateMachineProposalInput) ProtoMessage()    {}
func (*StateMachineProposalInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{1}
}
func (m *StateMachineProposalInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateMachineProposalInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateMachineProposalInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateMachineProposalInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateMachineProposalInput.Merge(m, src)
}
func (m *StateMachineProposalInput) XXX_Size() int {
	return m.Size()
}
func (m *StateMachineProposalInput) XXX_DiscardUnknown() {
	xxx_messageInfo_StateMachineProposalInput.DiscardUnknown(m)
}

var xxx_messageInfo_StateMachineProposalInput proto.InternalMessageInfo

type isStateMachineProposalInput_Input interface {
	isStateMachineProposalInput_Input()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StateMachineProposalInput_OpenSession struct {
	OpenSession *OpenSessionInput `protobuf:"bytes,1,opt,name=open_session,json=openSession,proto3,oneof" json:"open_session,omitempty"`
}
type StateMachineProposalInput_KeepAlive struct {
	KeepAlive *KeepAliveInput `protobuf:"bytes,2,opt,name=keep_alive,json=keepAlive,proto3,oneof" json:"keep_alive,omitempty"`
}
type StateMachineProposalInput_CloseSession struct {
	CloseSession *CloseSessionInput `protobuf:"bytes,3,opt,name=close_session,json=closeSession,proto3,oneof" json:"close_session,omitempty"`
}
type StateMachineProposalInput_Proposal struct {
	Proposal *SessionProposalInput `protobuf:"bytes,4,opt,name=proposal,proto3,oneof" json:"proposal,omitempty"`
}

func (*StateMachineProposalInput_OpenSession) isStateMachineProposalInput_Input()  {}
func (*StateMachineProposalInput_KeepAlive) isStateMachineProposalInput_Input()    {}
func (*StateMachineProposalInput_CloseSession) isStateMachineProposalInput_Input() {}
func (*StateMachineProposalInput_Proposal) isStateMachineProposalInput_Input()     {}

func (m *StateMachineProposalInput) GetInput() isStateMachineProposalInput_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *StateMachineProposalInput) GetOpenSession() *OpenSessionInput {
	if x, ok := m.GetInput().(*StateMachineProposalInput_OpenSession); ok {
		return x.OpenSession
	}
	return nil
}

func (m *StateMachineProposalInput) GetKeepAlive() *KeepAliveInput {
	if x, ok := m.GetInput().(*StateMachineProposalInput_KeepAlive); ok {
		return x.KeepAlive
	}
	return nil
}

func (m *StateMachineProposalInput) GetCloseSession() *CloseSessionInput {
	if x, ok := m.GetInput().(*StateMachineProposalInput_CloseSession); ok {
		return x.CloseSession
	}
	return nil
}

func (m *StateMachineProposalInput) GetProposal() *SessionProposalInput {
	if x, ok := m.GetInput().(*StateMachineProposalInput_Proposal); ok {
		return x.Proposal
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StateMachineProposalInput) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StateMachineProposalInput_OpenSession)(nil),
		(*StateMachineProposalInput_KeepAlive)(nil),
		(*StateMachineProposalInput_CloseSession)(nil),
		(*StateMachineProposalInput_Proposal)(nil),
	}
}

type StateMachineProposalOutput struct {
	Index Index `protobuf:"varint,1,opt,name=index,proto3,casttype=Index" json:"index,omitempty"`
	// Types that are valid to be assigned to Output:
	//	*StateMachineProposalOutput_OpenSession
	//	*StateMachineProposalOutput_KeepAlive
	//	*StateMachineProposalOutput_CloseSession
	//	*StateMachineProposalOutput_Proposal
	Output isStateMachineProposalOutput_Output `protobuf_oneof:"output"`
}

func (m *StateMachineProposalOutput) Reset()         { *m = StateMachineProposalOutput{} }
func (m *StateMachineProposalOutput) String() string { return proto.CompactTextString(m) }
func (*StateMachineProposalOutput) ProtoMessage()    {}
func (*StateMachineProposalOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{2}
}
func (m *StateMachineProposalOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateMachineProposalOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateMachineProposalOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateMachineProposalOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateMachineProposalOutput.Merge(m, src)
}
func (m *StateMachineProposalOutput) XXX_Size() int {
	return m.Size()
}
func (m *StateMachineProposalOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_StateMachineProposalOutput.DiscardUnknown(m)
}

var xxx_messageInfo_StateMachineProposalOutput proto.InternalMessageInfo

type isStateMachineProposalOutput_Output interface {
	isStateMachineProposalOutput_Output()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StateMachineProposalOutput_OpenSession struct {
	OpenSession *OpenSessionOutput `protobuf:"bytes,2,opt,name=open_session,json=openSession,proto3,oneof" json:"open_session,omitempty"`
}
type StateMachineProposalOutput_KeepAlive struct {
	KeepAlive *KeepAliveOutput `protobuf:"bytes,3,opt,name=keep_alive,json=keepAlive,proto3,oneof" json:"keep_alive,omitempty"`
}
type StateMachineProposalOutput_CloseSession struct {
	CloseSession *CloseSessionOutput `protobuf:"bytes,4,opt,name=close_session,json=closeSession,proto3,oneof" json:"close_session,omitempty"`
}
type StateMachineProposalOutput_Proposal struct {
	Proposal *SessionProposalOutput `protobuf:"bytes,5,opt,name=proposal,proto3,oneof" json:"proposal,omitempty"`
}

func (*StateMachineProposalOutput_OpenSession) isStateMachineProposalOutput_Output()  {}
func (*StateMachineProposalOutput_KeepAlive) isStateMachineProposalOutput_Output()    {}
func (*StateMachineProposalOutput_CloseSession) isStateMachineProposalOutput_Output() {}
func (*StateMachineProposalOutput_Proposal) isStateMachineProposalOutput_Output()     {}

func (m *StateMachineProposalOutput) GetOutput() isStateMachineProposalOutput_Output {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *StateMachineProposalOutput) GetIndex() Index {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *StateMachineProposalOutput) GetOpenSession() *OpenSessionOutput {
	if x, ok := m.GetOutput().(*StateMachineProposalOutput_OpenSession); ok {
		return x.OpenSession
	}
	return nil
}

func (m *StateMachineProposalOutput) GetKeepAlive() *KeepAliveOutput {
	if x, ok := m.GetOutput().(*StateMachineProposalOutput_KeepAlive); ok {
		return x.KeepAlive
	}
	return nil
}

func (m *StateMachineProposalOutput) GetCloseSession() *CloseSessionOutput {
	if x, ok := m.GetOutput().(*StateMachineProposalOutput_CloseSession); ok {
		return x.CloseSession
	}
	return nil
}

func (m *StateMachineProposalOutput) GetProposal() *SessionProposalOutput {
	if x, ok := m.GetOutput().(*StateMachineProposalOutput_Proposal); ok {
		return x.Proposal
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StateMachineProposalOutput) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StateMachineProposalOutput_OpenSession)(nil),
		(*StateMachineProposalOutput_KeepAlive)(nil),
		(*StateMachineProposalOutput_CloseSession)(nil),
		(*StateMachineProposalOutput_Proposal)(nil),
	}
}

type StateMachineQueryInput struct {
	MaxReceivedIndex Index `protobuf:"varint,1,opt,name=max_received_index,json=maxReceivedIndex,proto3,casttype=Index" json:"max_received_index,omitempty"`
	// Types that are valid to be assigned to Input:
	//	*StateMachineQueryInput_Query
	Input isStateMachineQueryInput_Input `protobuf_oneof:"input"`
}

func (m *StateMachineQueryInput) Reset()         { *m = StateMachineQueryInput{} }
func (m *StateMachineQueryInput) String() string { return proto.CompactTextString(m) }
func (*StateMachineQueryInput) ProtoMessage()    {}
func (*StateMachineQueryInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{3}
}
func (m *StateMachineQueryInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateMachineQueryInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateMachineQueryInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateMachineQueryInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateMachineQueryInput.Merge(m, src)
}
func (m *StateMachineQueryInput) XXX_Size() int {
	return m.Size()
}
func (m *StateMachineQueryInput) XXX_DiscardUnknown() {
	xxx_messageInfo_StateMachineQueryInput.DiscardUnknown(m)
}

var xxx_messageInfo_StateMachineQueryInput proto.InternalMessageInfo

type isStateMachineQueryInput_Input interface {
	isStateMachineQueryInput_Input()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StateMachineQueryInput_Query struct {
	Query *SessionQueryInput `protobuf:"bytes,2,opt,name=query,proto3,oneof" json:"query,omitempty"`
}

func (*StateMachineQueryInput_Query) isStateMachineQueryInput_Input() {}

func (m *StateMachineQueryInput) GetInput() isStateMachineQueryInput_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *StateMachineQueryInput) GetMaxReceivedIndex() Index {
	if m != nil {
		return m.MaxReceivedIndex
	}
	return 0
}

func (m *StateMachineQueryInput) GetQuery() *SessionQueryInput {
	if x, ok := m.GetInput().(*StateMachineQueryInput_Query); ok {
		return x.Query
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StateMachineQueryInput) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StateMachineQueryInput_Query)(nil),
	}
}

type StateMachineQueryOutput struct {
	Index Index `protobuf:"varint,1,opt,name=index,proto3,casttype=Index" json:"index,omitempty"`
	// Types that are valid to be assigned to Output:
	//	*StateMachineQueryOutput_Query
	Output isStateMachineQueryOutput_Output `protobuf_oneof:"output"`
}

func (m *StateMachineQueryOutput) Reset()         { *m = StateMachineQueryOutput{} }
func (m *StateMachineQueryOutput) String() string { return proto.CompactTextString(m) }
func (*StateMachineQueryOutput) ProtoMessage()    {}
func (*StateMachineQueryOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{4}
}
func (m *StateMachineQueryOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateMachineQueryOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateMachineQueryOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateMachineQueryOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateMachineQueryOutput.Merge(m, src)
}
func (m *StateMachineQueryOutput) XXX_Size() int {
	return m.Size()
}
func (m *StateMachineQueryOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_StateMachineQueryOutput.DiscardUnknown(m)
}

var xxx_messageInfo_StateMachineQueryOutput proto.InternalMessageInfo

type isStateMachineQueryOutput_Output interface {
	isStateMachineQueryOutput_Output()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StateMachineQueryOutput_Query struct {
	Query *SessionQueryOutput `protobuf:"bytes,2,opt,name=query,proto3,oneof" json:"query,omitempty"`
}

func (*StateMachineQueryOutput_Query) isStateMachineQueryOutput_Output() {}

func (m *StateMachineQueryOutput) GetOutput() isStateMachineQueryOutput_Output {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *StateMachineQueryOutput) GetIndex() Index {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *StateMachineQueryOutput) GetQuery() *SessionQueryOutput {
	if x, ok := m.GetOutput().(*StateMachineQueryOutput_Query); ok {
		return x.Query
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StateMachineQueryOutput) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StateMachineQueryOutput_Query)(nil),
	}
}

type OpenSessionInput struct {
	Timeout time.Duration `protobuf:"bytes,1,opt,name=timeout,proto3,stdduration" json:"timeout"`
}

func (m *OpenSessionInput) Reset()         { *m = OpenSessionInput{} }
func (m *OpenSessionInput) String() string { return proto.CompactTextString(m) }
func (*OpenSessionInput) ProtoMessage()    {}
func (*OpenSessionInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{5}
}
func (m *OpenSessionInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenSessionInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenSessionInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenSessionInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenSessionInput.Merge(m, src)
}
func (m *OpenSessionInput) XXX_Size() int {
	return m.Size()
}
func (m *OpenSessionInput) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenSessionInput.DiscardUnknown(m)
}

var xxx_messageInfo_OpenSessionInput proto.InternalMessageInfo

func (m *OpenSessionInput) GetTimeout() time.Duration {
	if m != nil {
		return m.Timeout
	}
	return 0
}

type OpenSessionOutput struct {
	SessionID SessionID `protobuf:"varint,1,opt,name=session_id,json=sessionId,proto3,casttype=SessionID" json:"session_id,omitempty"`
}

func (m *OpenSessionOutput) Reset()         { *m = OpenSessionOutput{} }
func (m *OpenSessionOutput) String() string { return proto.CompactTextString(m) }
func (*OpenSessionOutput) ProtoMessage()    {}
func (*OpenSessionOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{6}
}
func (m *OpenSessionOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenSessionOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenSessionOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenSessionOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenSessionOutput.Merge(m, src)
}
func (m *OpenSessionOutput) XXX_Size() int {
	return m.Size()
}
func (m *OpenSessionOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenSessionOutput.DiscardUnknown(m)
}

var xxx_messageInfo_OpenSessionOutput proto.InternalMessageInfo

func (m *OpenSessionOutput) GetSessionID() SessionID {
	if m != nil {
		return m.SessionID
	}
	return 0
}

type KeepAliveInput struct {
	SessionID              SessionID                   `protobuf:"varint,1,opt,name=session_id,json=sessionId,proto3,casttype=SessionID" json:"session_id,omitempty"`
	InputFilter            []byte                      `protobuf:"bytes,2,opt,name=input_filter,json=inputFilter,proto3" json:"input_filter,omitempty"`
	LastInputSequenceNum   SequenceNum                 `protobuf:"varint,3,opt,name=last_input_sequence_num,json=lastInputSequenceNum,proto3,casttype=SequenceNum" json:"last_input_sequence_num,omitempty"`
	LastOutputSequenceNums map[SequenceNum]SequenceNum `protobuf:"bytes,4,rep,name=last_output_sequence_nums,json=lastOutputSequenceNums,proto3,castkey=SequenceNum,castvalue=SequenceNum" json:"last_output_sequence_nums,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *KeepAliveInput) Reset()         { *m = KeepAliveInput{} }
func (m *KeepAliveInput) String() string { return proto.CompactTextString(m) }
func (*KeepAliveInput) ProtoMessage()    {}
func (*KeepAliveInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{7}
}
func (m *KeepAliveInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeepAliveInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeepAliveInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeepAliveInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeepAliveInput.Merge(m, src)
}
func (m *KeepAliveInput) XXX_Size() int {
	return m.Size()
}
func (m *KeepAliveInput) XXX_DiscardUnknown() {
	xxx_messageInfo_KeepAliveInput.DiscardUnknown(m)
}

var xxx_messageInfo_KeepAliveInput proto.InternalMessageInfo

func (m *KeepAliveInput) GetSessionID() SessionID {
	if m != nil {
		return m.SessionID
	}
	return 0
}

func (m *KeepAliveInput) GetInputFilter() []byte {
	if m != nil {
		return m.InputFilter
	}
	return nil
}

func (m *KeepAliveInput) GetLastInputSequenceNum() SequenceNum {
	if m != nil {
		return m.LastInputSequenceNum
	}
	return 0
}

func (m *KeepAliveInput) GetLastOutputSequenceNums() map[SequenceNum]SequenceNum {
	if m != nil {
		return m.LastOutputSequenceNums
	}
	return nil
}

type KeepAliveOutput struct {
}

func (m *KeepAliveOutput) Reset()         { *m = KeepAliveOutput{} }
func (m *KeepAliveOutput) String() string { return proto.CompactTextString(m) }
func (*KeepAliveOutput) ProtoMessage()    {}
func (*KeepAliveOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{8}
}
func (m *KeepAliveOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeepAliveOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeepAliveOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeepAliveOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeepAliveOutput.Merge(m, src)
}
func (m *KeepAliveOutput) XXX_Size() int {
	return m.Size()
}
func (m *KeepAliveOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_KeepAliveOutput.DiscardUnknown(m)
}

var xxx_messageInfo_KeepAliveOutput proto.InternalMessageInfo

type CloseSessionInput struct {
	SessionID SessionID `protobuf:"varint,1,opt,name=session_id,json=sessionId,proto3,casttype=SessionID" json:"session_id,omitempty"`
}

func (m *CloseSessionInput) Reset()         { *m = CloseSessionInput{} }
func (m *CloseSessionInput) String() string { return proto.CompactTextString(m) }
func (*CloseSessionInput) ProtoMessage()    {}
func (*CloseSessionInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{9}
}
func (m *CloseSessionInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloseSessionInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloseSessionInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloseSessionInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloseSessionInput.Merge(m, src)
}
func (m *CloseSessionInput) XXX_Size() int {
	return m.Size()
}
func (m *CloseSessionInput) XXX_DiscardUnknown() {
	xxx_messageInfo_CloseSessionInput.DiscardUnknown(m)
}

var xxx_messageInfo_CloseSessionInput proto.InternalMessageInfo

func (m *CloseSessionInput) GetSessionID() SessionID {
	if m != nil {
		return m.SessionID
	}
	return 0
}

type CloseSessionOutput struct {
}

func (m *CloseSessionOutput) Reset()         { *m = CloseSessionOutput{} }
func (m *CloseSessionOutput) String() string { return proto.CompactTextString(m) }
func (*CloseSessionOutput) ProtoMessage()    {}
func (*CloseSessionOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{10}
}
func (m *CloseSessionOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloseSessionOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloseSessionOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloseSessionOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloseSessionOutput.Merge(m, src)
}
func (m *CloseSessionOutput) XXX_Size() int {
	return m.Size()
}
func (m *CloseSessionOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_CloseSessionOutput.DiscardUnknown(m)
}

var xxx_messageInfo_CloseSessionOutput proto.InternalMessageInfo

type SessionProposalInput struct {
	SessionID   SessionID   `protobuf:"varint,1,opt,name=session_id,json=sessionId,proto3,casttype=SessionID" json:"session_id,omitempty"`
	SequenceNum SequenceNum `protobuf:"varint,2,opt,name=sequence_num,json=sequenceNum,proto3,casttype=SequenceNum" json:"sequence_num,omitempty"`
	Deadline    *time.Time  `protobuf:"bytes,3,opt,name=deadline,proto3,stdtime" json:"deadline,omitempty"`
	// Types that are valid to be assigned to Input:
	//	*SessionProposalInput_CreatePrimitive
	//	*SessionProposalInput_ClosePrimitive
	//	*SessionProposalInput_Proposal
	Input isSessionProposalInput_Input `protobuf_oneof:"input"`
}

func (m *SessionProposalInput) Reset()         { *m = SessionProposalInput{} }
func (m *SessionProposalInput) String() string { return proto.CompactTextString(m) }
func (*SessionProposalInput) ProtoMessage()    {}
func (*SessionProposalInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{11}
}
func (m *SessionProposalInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionProposalInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionProposalInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionProposalInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionProposalInput.Merge(m, src)
}
func (m *SessionProposalInput) XXX_Size() int {
	return m.Size()
}
func (m *SessionProposalInput) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionProposalInput.DiscardUnknown(m)
}

var xxx_messageInfo_SessionProposalInput proto.InternalMessageInfo

type isSessionProposalInput_Input interface {
	isSessionProposalInput_Input()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SessionProposalInput_CreatePrimitive struct {
	CreatePrimitive *CreatePrimitiveInput `protobuf:"bytes,4,opt,name=create_primitive,json=createPrimitive,proto3,oneof" json:"create_primitive,omitempty"`
}
type SessionProposalInput_ClosePrimitive struct {
	ClosePrimitive *ClosePrimitiveInput `protobuf:"bytes,5,opt,name=close_primitive,json=closePrimitive,proto3,oneof" json:"close_primitive,omitempty"`
}
type SessionProposalInput_Proposal struct {
	Proposal *PrimitiveProposalInput `protobuf:"bytes,6,opt,name=proposal,proto3,oneof" json:"proposal,omitempty"`
}

func (*SessionProposalInput_CreatePrimitive) isSessionProposalInput_Input() {}
func (*SessionProposalInput_ClosePrimitive) isSessionProposalInput_Input()  {}
func (*SessionProposalInput_Proposal) isSessionProposalInput_Input()        {}

func (m *SessionProposalInput) GetInput() isSessionProposalInput_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *SessionProposalInput) GetSessionID() SessionID {
	if m != nil {
		return m.SessionID
	}
	return 0
}

func (m *SessionProposalInput) GetSequenceNum() SequenceNum {
	if m != nil {
		return m.SequenceNum
	}
	return 0
}

func (m *SessionProposalInput) GetDeadline() *time.Time {
	if m != nil {
		return m.Deadline
	}
	return nil
}

func (m *SessionProposalInput) GetCreatePrimitive() *CreatePrimitiveInput {
	if x, ok := m.GetInput().(*SessionProposalInput_CreatePrimitive); ok {
		return x.CreatePrimitive
	}
	return nil
}

func (m *SessionProposalInput) GetClosePrimitive() *ClosePrimitiveInput {
	if x, ok := m.GetInput().(*SessionProposalInput_ClosePrimitive); ok {
		return x.ClosePrimitive
	}
	return nil
}

func (m *SessionProposalInput) GetProposal() *PrimitiveProposalInput {
	if x, ok := m.GetInput().(*SessionProposalInput_Proposal); ok {
		return x.Proposal
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SessionProposalInput) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SessionProposalInput_CreatePrimitive)(nil),
		(*SessionProposalInput_ClosePrimitive)(nil),
		(*SessionProposalInput_Proposal)(nil),
	}
}

type SessionProposalOutput struct {
	SequenceNum SequenceNum `protobuf:"varint,1,opt,name=sequence_num,json=sequenceNum,proto3,casttype=SequenceNum" json:"sequence_num,omitempty"`
	Failure     *Failure    `protobuf:"bytes,2,opt,name=failure,proto3" json:"failure,omitempty"`
	// Types that are valid to be assigned to Output:
	//	*SessionProposalOutput_CreatePrimitive
	//	*SessionProposalOutput_ClosePrimitive
	//	*SessionProposalOutput_Proposal
	Output isSessionProposalOutput_Output `protobuf_oneof:"output"`
}

func (m *SessionProposalOutput) Reset()         { *m = SessionProposalOutput{} }
func (m *SessionProposalOutput) String() string { return proto.CompactTextString(m) }
func (*SessionProposalOutput) ProtoMessage()    {}
func (*SessionProposalOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{12}
}
func (m *SessionProposalOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionProposalOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionProposalOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionProposalOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionProposalOutput.Merge(m, src)
}
func (m *SessionProposalOutput) XXX_Size() int {
	return m.Size()
}
func (m *SessionProposalOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionProposalOutput.DiscardUnknown(m)
}

var xxx_messageInfo_SessionProposalOutput proto.InternalMessageInfo

type isSessionProposalOutput_Output interface {
	isSessionProposalOutput_Output()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SessionProposalOutput_CreatePrimitive struct {
	CreatePrimitive *CreatePrimitiveOutput `protobuf:"bytes,3,opt,name=create_primitive,json=createPrimitive,proto3,oneof" json:"create_primitive,omitempty"`
}
type SessionProposalOutput_ClosePrimitive struct {
	ClosePrimitive *ClosePrimitiveOutput `protobuf:"bytes,4,opt,name=close_primitive,json=closePrimitive,proto3,oneof" json:"close_primitive,omitempty"`
}
type SessionProposalOutput_Proposal struct {
	Proposal *PrimitiveProposalOutput `protobuf:"bytes,5,opt,name=proposal,proto3,oneof" json:"proposal,omitempty"`
}

func (*SessionProposalOutput_CreatePrimitive) isSessionProposalOutput_Output() {}
func (*SessionProposalOutput_ClosePrimitive) isSessionProposalOutput_Output()  {}
func (*SessionProposalOutput_Proposal) isSessionProposalOutput_Output()        {}

func (m *SessionProposalOutput) GetOutput() isSessionProposalOutput_Output {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *SessionProposalOutput) GetSequenceNum() SequenceNum {
	if m != nil {
		return m.SequenceNum
	}
	return 0
}

func (m *SessionProposalOutput) GetFailure() *Failure {
	if m != nil {
		return m.Failure
	}
	return nil
}

func (m *SessionProposalOutput) GetCreatePrimitive() *CreatePrimitiveOutput {
	if x, ok := m.GetOutput().(*SessionProposalOutput_CreatePrimitive); ok {
		return x.CreatePrimitive
	}
	return nil
}

func (m *SessionProposalOutput) GetClosePrimitive() *ClosePrimitiveOutput {
	if x, ok := m.GetOutput().(*SessionProposalOutput_ClosePrimitive); ok {
		return x.ClosePrimitive
	}
	return nil
}

func (m *SessionProposalOutput) GetProposal() *PrimitiveProposalOutput {
	if x, ok := m.GetOutput().(*SessionProposalOutput_Proposal); ok {
		return x.Proposal
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SessionProposalOutput) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SessionProposalOutput_CreatePrimitive)(nil),
		(*SessionProposalOutput_ClosePrimitive)(nil),
		(*SessionProposalOutput_Proposal)(nil),
	}
}

type SessionQueryInput struct {
	SessionID SessionID  `protobuf:"varint,1,opt,name=session_id,json=sessionId,proto3,casttype=SessionID" json:"session_id,omitempty"`
	Deadline  *time.Time `protobuf:"bytes,2,opt,name=deadline,proto3,stdtime" json:"deadline,omitempty"`
	// Types that are valid to be assigned to Input:
	//	*SessionQueryInput_Query
	Input isSessionQueryInput_Input `protobuf_oneof:"input"`
}

func (m *SessionQueryInput) Reset()         { *m = SessionQueryInput{} }
func (m *SessionQueryInput) String() string { return proto.CompactTextString(m) }
func (*SessionQueryInput) ProtoMessage()    {}
func (*SessionQueryInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{13}
}
func (m *SessionQueryInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionQueryInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionQueryInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionQueryInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionQueryInput.Merge(m, src)
}
func (m *SessionQueryInput) XXX_Size() int {
	return m.Size()
}
func (m *SessionQueryInput) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionQueryInput.DiscardUnknown(m)
}

var xxx_messageInfo_SessionQueryInput proto.InternalMessageInfo

type isSessionQueryInput_Input interface {
	isSessionQueryInput_Input()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SessionQueryInput_Query struct {
	Query *PrimitiveQueryInput `protobuf:"bytes,3,opt,name=query,proto3,oneof" json:"query,omitempty"`
}

func (*SessionQueryInput_Query) isSessionQueryInput_Input() {}

func (m *SessionQueryInput) GetInput() isSessionQueryInput_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *SessionQueryInput) GetSessionID() SessionID {
	if m != nil {
		return m.SessionID
	}
	return 0
}

func (m *SessionQueryInput) GetDeadline() *time.Time {
	if m != nil {
		return m.Deadline
	}
	return nil
}

func (m *SessionQueryInput) GetQuery() *PrimitiveQueryInput {
	if x, ok := m.GetInput().(*SessionQueryInput_Query); ok {
		return x.Query
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SessionQueryInput) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SessionQueryInput_Query)(nil),
	}
}

type SessionQueryOutput struct {
	Failure *Failure `protobuf:"bytes,1,opt,name=failure,proto3" json:"failure,omitempty"`
	// Types that are valid to be assigned to Output:
	//	*SessionQueryOutput_Query
	Output isSessionQueryOutput_Output `protobuf_oneof:"output"`
}

func (m *SessionQueryOutput) Reset()         { *m = SessionQueryOutput{} }
func (m *SessionQueryOutput) String() string { return proto.CompactTextString(m) }
func (*SessionQueryOutput) ProtoMessage()    {}
func (*SessionQueryOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{14}
}
func (m *SessionQueryOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionQueryOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionQueryOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionQueryOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionQueryOutput.Merge(m, src)
}
func (m *SessionQueryOutput) XXX_Size() int {
	return m.Size()
}
func (m *SessionQueryOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionQueryOutput.DiscardUnknown(m)
}

var xxx_messageInfo_SessionQueryOutput proto.InternalMessageInfo

type isSessionQueryOutput_Output interface {
	isSessionQueryOutput_Output()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SessionQueryOutput_Query struct {
	Query *PrimitiveQueryOutput `protobuf:"bytes,2,opt,name=query,proto3,oneof" json:"query,omitempty"`
}

func (*SessionQueryOutput_Query) isSessionQueryOutput_Output() {}

func (m *SessionQueryOutput) GetOutput() isSessionQueryOutput_Output {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *SessionQueryOutput) GetFailure() *Failure {
	if m != nil {
		return m.Failure
	}
	return nil
}

func (m *SessionQueryOutput) GetQuery() *PrimitiveQueryOutput {
	if x, ok := m.GetOutput().(*SessionQueryOutput_Query); ok {
		return x.Query
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SessionQueryOutput) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SessionQueryOutput_Query)(nil),
	}
}

type CreatePrimitiveInput struct {
	PrimitiveSpec `protobuf:"bytes,1,opt,name=spec,proto3,embedded=spec" json:"spec"`
}

func (m *CreatePrimitiveInput) Reset()         { *m = CreatePrimitiveInput{} }
func (m *CreatePrimitiveInput) String() string { return proto.CompactTextString(m) }
func (*CreatePrimitiveInput) ProtoMessage()    {}
func (*CreatePrimitiveInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{15}
}
func (m *CreatePrimitiveInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreatePrimitiveInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreatePrimitiveInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreatePrimitiveInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreatePrimitiveInput.Merge(m, src)
}
func (m *CreatePrimitiveInput) XXX_Size() int {
	return m.Size()
}
func (m *CreatePrimitiveInput) XXX_DiscardUnknown() {
	xxx_messageInfo_CreatePrimitiveInput.DiscardUnknown(m)
}

var xxx_messageInfo_CreatePrimitiveInput proto.InternalMessageInfo

type CreatePrimitiveOutput struct {
	PrimitiveID PrimitiveID `protobuf:"varint,1,opt,name=primitive_id,json=primitiveId,proto3,casttype=PrimitiveID" json:"primitive_id,omitempty"`
}

func (m *CreatePrimitiveOutput) Reset()         { *m = CreatePrimitiveOutput{} }
func (m *CreatePrimitiveOutput) String() string { return proto.CompactTextString(m) }
func (*CreatePrimitiveOutput) ProtoMessage()    {}
func (*CreatePrimitiveOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{16}
}
func (m *CreatePrimitiveOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreatePrimitiveOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreatePrimitiveOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreatePrimitiveOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreatePrimitiveOutput.Merge(m, src)
}
func (m *CreatePrimitiveOutput) XXX_Size() int {
	return m.Size()
}
func (m *CreatePrimitiveOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_CreatePrimitiveOutput.DiscardUnknown(m)
}

var xxx_messageInfo_CreatePrimitiveOutput proto.InternalMessageInfo

func (m *CreatePrimitiveOutput) GetPrimitiveID() PrimitiveID {
	if m != nil {
		return m.PrimitiveID
	}
	return 0
}

type ClosePrimitiveInput struct {
	PrimitiveID PrimitiveID `protobuf:"varint,1,opt,name=primitive_id,json=primitiveId,proto3,casttype=PrimitiveID" json:"primitive_id,omitempty"`
}

func (m *ClosePrimitiveInput) Reset()         { *m = ClosePrimitiveInput{} }
func (m *ClosePrimitiveInput) String() string { return proto.CompactTextString(m) }
func (*ClosePrimitiveInput) ProtoMessage()    {}
func (*ClosePrimitiveInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{17}
}
func (m *ClosePrimitiveInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClosePrimitiveInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClosePrimitiveInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClosePrimitiveInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClosePrimitiveInput.Merge(m, src)
}
func (m *ClosePrimitiveInput) XXX_Size() int {
	return m.Size()
}
func (m *ClosePrimitiveInput) XXX_DiscardUnknown() {
	xxx_messageInfo_ClosePrimitiveInput.DiscardUnknown(m)
}

var xxx_messageInfo_ClosePrimitiveInput proto.InternalMessageInfo

func (m *ClosePrimitiveInput) GetPrimitiveID() PrimitiveID {
	if m != nil {
		return m.PrimitiveID
	}
	return 0
}

type ClosePrimitiveOutput struct {
}

func (m *ClosePrimitiveOutput) Reset()         { *m = ClosePrimitiveOutput{} }
func (m *ClosePrimitiveOutput) String() string { return proto.CompactTextString(m) }
func (*ClosePrimitiveOutput) ProtoMessage()    {}
func (*ClosePrimitiveOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{18}
}
func (m *ClosePrimitiveOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClosePrimitiveOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClosePrimitiveOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClosePrimitiveOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClosePrimitiveOutput.Merge(m, src)
}
func (m *ClosePrimitiveOutput) XXX_Size() int {
	return m.Size()
}
func (m *ClosePrimitiveOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_ClosePrimitiveOutput.DiscardUnknown(m)
}

var xxx_messageInfo_ClosePrimitiveOutput proto.InternalMessageInfo

type PrimitiveProposalInput struct {
	PrimitiveID PrimitiveID `protobuf:"varint,1,opt,name=primitive_id,json=primitiveId,proto3,casttype=PrimitiveID" json:"primitive_id,omitempty"`
	Payload     []byte      `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *PrimitiveProposalInput) Reset()         { *m = PrimitiveProposalInput{} }
func (m *PrimitiveProposalInput) String() string { return proto.CompactTextString(m) }
func (*PrimitiveProposalInput) ProtoMessage()    {}
func (*PrimitiveProposalInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{19}
}
func (m *PrimitiveProposalInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrimitiveProposalInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrimitiveProposalInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrimitiveProposalInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrimitiveProposalInput.Merge(m, src)
}
func (m *PrimitiveProposalInput) XXX_Size() int {
	return m.Size()
}
func (m *PrimitiveProposalInput) XXX_DiscardUnknown() {
	xxx_messageInfo_PrimitiveProposalInput.DiscardUnknown(m)
}

var xxx_messageInfo_PrimitiveProposalInput proto.InternalMessageInfo

func (m *PrimitiveProposalInput) GetPrimitiveID() PrimitiveID {
	if m != nil {
		return m.PrimitiveID
	}
	return 0
}

func (m *PrimitiveProposalInput) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type PrimitiveProposalOutput struct {
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *PrimitiveProposalOutput) Reset()         { *m = PrimitiveProposalOutput{} }
func (m *PrimitiveProposalOutput) String() string { return proto.CompactTextString(m) }
func (*PrimitiveProposalOutput) ProtoMessage()    {}
func (*PrimitiveProposalOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{20}
}
func (m *PrimitiveProposalOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrimitiveProposalOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrimitiveProposalOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrimitiveProposalOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrimitiveProposalOutput.Merge(m, src)
}
func (m *PrimitiveProposalOutput) XXX_Size() int {
	return m.Size()
}
func (m *PrimitiveProposalOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_PrimitiveProposalOutput.DiscardUnknown(m)
}

var xxx_messageInfo_PrimitiveProposalOutput proto.InternalMessageInfo

func (m *PrimitiveProposalOutput) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type PrimitiveQueryInput struct {
	PrimitiveID PrimitiveID `protobuf:"varint,1,opt,name=primitive_id,json=primitiveId,proto3,casttype=PrimitiveID" json:"primitive_id,omitempty"`
	Payload     []byte      `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *PrimitiveQueryInput) Reset()         { *m = PrimitiveQueryInput{} }
func (m *PrimitiveQueryInput) String() string { return proto.CompactTextString(m) }
func (*PrimitiveQueryInput) ProtoMessage()    {}
func (*PrimitiveQueryInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{21}
}
func (m *PrimitiveQueryInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrimitiveQueryInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrimitiveQueryInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrimitiveQueryInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrimitiveQueryInput.Merge(m, src)
}
func (m *PrimitiveQueryInput) XXX_Size() int {
	return m.Size()
}
func (m *PrimitiveQueryInput) XXX_DiscardUnknown() {
	xxx_messageInfo_PrimitiveQueryInput.DiscardUnknown(m)
}

var xxx_messageInfo_PrimitiveQueryInput proto.InternalMessageInfo

func (m *PrimitiveQueryInput) GetPrimitiveID() PrimitiveID {
	if m != nil {
		return m.PrimitiveID
	}
	return 0
}

func (m *PrimitiveQueryInput) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type PrimitiveQueryOutput struct {
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *PrimitiveQueryOutput) Reset()         { *m = PrimitiveQueryOutput{} }
func (m *PrimitiveQueryOutput) String() string { return proto.CompactTextString(m) }
func (*PrimitiveQueryOutput) ProtoMessage()    {}
func (*PrimitiveQueryOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{22}
}
func (m *PrimitiveQueryOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrimitiveQueryOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrimitiveQueryOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrimitiveQueryOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrimitiveQueryOutput.Merge(m, src)
}
func (m *PrimitiveQueryOutput) XXX_Size() int {
	return m.Size()
}
func (m *PrimitiveQueryOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_PrimitiveQueryOutput.DiscardUnknown(m)
}

var xxx_messageInfo_PrimitiveQueryOutput proto.InternalMessageInfo

func (m *PrimitiveQueryOutput) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type Failure struct {
	Status  Failure_Status `protobuf:"varint,1,opt,name=status,proto3,enum=atomix.multiraft.v1.Failure_Status" json:"status,omitempty"`
	Message string         `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *Failure) Reset()         { *m = Failure{} }
func (m *Failure) String() string { return proto.CompactTextString(m) }
func (*Failure) ProtoMessage()    {}
func (*Failure) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{23}
}
func (m *Failure) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Failure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Failure.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Failure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Failure.Merge(m, src)
}
func (m *Failure) XXX_Size() int {
	return m.Size()
}
func (m *Failure) XXX_DiscardUnknown() {
	xxx_messageInfo_Failure.DiscardUnknown(m)
}

var xxx_messageInfo_Failure proto.InternalMessageInfo

func (m *Failure) GetStatus() Failure_Status {
	if m != nil {
		return m.Status
	}
	return Failure_UNKNOWN
}

func (m *Failure) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type Snapshot struct {
	Index     Index     `protobuf:"varint,1,opt,name=index,proto3,casttype=Index" json:"index,omitempty"`
	Timestamp time.Time `protobuf:"bytes,2,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
}

func (m *Snapshot) Reset()         { *m = Snapshot{} }
func (m *Snapshot) String() string { return proto.CompactTextString(m) }
func (*Snapshot) ProtoMessage()    {}
func (*Snapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{24}
}
func (m *Snapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Snapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Snapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Snapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot.Merge(m, src)
}
func (m *Snapshot) XXX_Size() int {
	return m.Size()
}
func (m *Snapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot proto.InternalMessageInfo

func (m *Snapshot) GetIndex() Index {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Snapshot) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

type PrimitiveSnapshot struct {
	PrimitiveID PrimitiveID   `protobuf:"varint,1,opt,name=primitive_id,json=primitiveId,proto3,casttype=PrimitiveID" json:"primitive_id,omitempty"`
	Spec        PrimitiveSpec `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec"`
}

func (m *PrimitiveSnapshot) Reset()         { *m = PrimitiveSnapshot{} }
func (m *PrimitiveSnapshot) String() string { return proto.CompactTextString(m) }
func (*PrimitiveSnapshot) ProtoMessage()    {}
func (*PrimitiveSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{25}
}
func (m *PrimitiveSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrimitiveSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrimitiveSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrimitiveSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrimitiveSnapshot.Merge(m, src)
}
func (m *PrimitiveSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *PrimitiveSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_PrimitiveSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_PrimitiveSnapshot proto.InternalMessageInfo

func (m *PrimitiveSnapshot) GetPrimitiveID() PrimitiveID {
	if m != nil {
		return m.PrimitiveID
	}
	return 0
}

func (m *PrimitiveSnapshot) GetSpec() PrimitiveSpec {
	if m != nil {
		return m.Spec
	}
	return PrimitiveSpec{}
}

type PrimitiveSpec struct {
	Service   string `protobuf:"bytes,1,opt,name=service,proto3" json:"service,omitempty"`
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Name      string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *PrimitiveSpec) Reset()         { *m = PrimitiveSpec{} }
func (m *PrimitiveSpec) String() string { return proto.CompactTextString(m) }
func (*PrimitiveSpec) ProtoMessage()    {}
func (*PrimitiveSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{26}
}
func (m *PrimitiveSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrimitiveSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrimitiveSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrimitiveSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrimitiveSpec.Merge(m, src)
}
func (m *PrimitiveSpec) XXX_Size() int {
	return m.Size()
}
func (m *PrimitiveSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PrimitiveSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PrimitiveSpec proto.InternalMessageInfo

func (m *PrimitiveSpec) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

func (m *PrimitiveSpec) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *PrimitiveSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type SessionSnapshot struct {
	SessionID   SessionID             `protobuf:"varint,1,opt,name=session_id,json=sessionId,proto3,casttype=SessionID" json:"session_id,omitempty"`
	State       SessionSnapshot_State `protobuf:"varint,2,opt,name=state,proto3,enum=atomix.multiraft.v1.SessionSnapshot_State" json:"state,omitempty"`
	Timeout     time.Duration         `protobuf:"bytes,3,opt,name=timeout,proto3,stdduration" json:"timeout"`
	LastUpdated time.Time             `protobuf:"bytes,4,opt,name=last_updated,json=lastUpdated,proto3,stdtime" json:"last_updated"`
}

func (m *SessionSnapshot) Reset()         { *m = SessionSnapshot{} }
func (m *SessionSnapshot) String() string { return proto.CompactTextString(m) }
func (*SessionSnapshot) ProtoMessage()    {}
func (*SessionSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{27}
}
func (m *SessionSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionSnapshot.Merge(m, src)
}
func (m *SessionSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *SessionSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_SessionSnapshot proto.InternalMessageInfo

func (m *SessionSnapshot) GetSessionID() SessionID {
	if m != nil {
		return m.SessionID
	}
	return 0
}

func (m *SessionSnapshot) GetState() SessionSnapshot_State {
	if m != nil {
		return m.State
	}
	return SessionSnapshot_UNKNOWN
}

func (m *SessionSnapshot) GetTimeout() time.Duration {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *SessionSnapshot) GetLastUpdated() time.Time {
	if m != nil {
		return m.LastUpdated
	}
	return time.Time{}
}

type SessionProposalSnapshot struct {
	Index                 Index                         `protobuf:"varint,1,opt,name=index,proto3,casttype=Index" json:"index,omitempty"`
	Phase                 SessionProposalSnapshot_Phase `protobuf:"varint,2,opt,name=phase,proto3,enum=atomix.multiraft.v1.SessionProposalSnapshot_Phase" json:"phase,omitempty"`
	Input                 *SessionProposalInput         `protobuf:"bytes,3,opt,name=input,proto3" json:"input,omitempty"`
	PendingOutputs        []*SessionProposalOutput      `protobuf:"bytes,4,rep,name=pending_outputs,json=pendingOutputs,proto3" json:"pending_outputs,omitempty"`
	LastOutputSequenceNum SequenceNum                   `protobuf:"varint,5,opt,name=last_output_sequence_num,json=lastOutputSequenceNum,proto3,casttype=SequenceNum" json:"last_output_sequence_num,omitempty"`
}

func (m *SessionProposalSnapshot) Reset()         { *m = SessionProposalSnapshot{} }
func (m *SessionProposalSnapshot) String() string { return proto.CompactTextString(m) }
func (*SessionProposalSnapshot) ProtoMessage()    {}
func (*SessionProposalSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_9ab16e7f9ceaca8f, []int{28}
}
func (m *SessionProposalSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionProposalSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionProposalSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionProposalSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionProposalSnapshot.Merge(m, src)
}
func (m *SessionProposalSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *SessionProposalSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionProposalSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_SessionProposalSnapshot proto.InternalMessageInfo

func (m *SessionProposalSnapshot) GetIndex() Index {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *SessionProposalSnapshot) GetPhase() SessionProposalSnapshot_Phase {
	if m != nil {
		return m.Phase
	}
	return SessionProposalSnapshot_PENDING
}

func (m *SessionProposalSnapshot) GetInput() *SessionProposalInput {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *SessionProposalSnapshot) GetPendingOutputs() []*SessionProposalOutput {
	if m != nil {
		return m.PendingOutputs
	}
	return nil
}

func (m *SessionProposalSnapshot) GetLastOutputSequenceNum() SequenceNum {
	if m != nil {
		return m.LastOutputSequenceNum
	}
	return 0
}

func init() {
	proto.RegisterEnum("atomix.multiraft.v1.Failure_Status", Failure_Status_name, Failure_Status_value)
	proto.RegisterEnum("atomix.multiraft.v1.SessionSnapshot_State", SessionSnapshot_State_name, SessionSnapshot_State_value)
	proto.RegisterEnum("atomix.multiraft.v1.SessionProposalSnapshot_Phase", SessionProposalSnapshot_Phase_name, SessionProposalSnapshot_Phase_value)
	proto.RegisterType((*RaftProposal)(nil), "atomix.multiraft.v1.RaftProposal")
	proto.RegisterType((*StateMachineProposalInput)(nil), "atomix.multiraft.v1.StateMachineProposalInput")
	proto.RegisterType((*StateMachineProposalOutput)(nil), "atomix.multiraft.v1.StateMachineProposalOutput")
	proto.RegisterType((*StateMachineQueryInput)(nil), "atomix.multiraft.v1.StateMachineQueryInput")
	proto.RegisterType((*StateMachineQueryOutput)(nil), "atomix.multiraft.v1.StateMachineQueryOutput")
	proto.RegisterType((*OpenSessionInput)(nil), "atomix.multiraft.v1.OpenSessionInput")
	proto.RegisterType((*OpenSessionOutput)(nil), "atomix.multiraft.v1.OpenSessionOutput")
	proto.RegisterType((*KeepAliveInput)(nil), "atomix.multiraft.v1.KeepAliveInput")
	proto.RegisterMapType((map[SequenceNum]SequenceNum)(nil), "atomix.multiraft.v1.KeepAliveInput.LastOutputSequenceNumsEntry")
	proto.RegisterType((*KeepAliveOutput)(nil), "atomix.multiraft.v1.KeepAliveOutput")
	proto.RegisterType((*CloseSessionInput)(nil), "atomix.multiraft.v1.CloseSessionInput")
	proto.RegisterType((*CloseSessionOutput)(nil), "atomix.multiraft.v1.CloseSessionOutput")
	proto.RegisterType((*SessionProposalInput)(nil), "atomix.multiraft.v1.SessionProposalInput")
	proto.RegisterType((*SessionProposalOutput)(nil), "atomix.multiraft.v1.SessionProposalOutput")
	proto.RegisterType((*SessionQueryInput)(nil), "atomix.multiraft.v1.SessionQueryInput")
	proto.RegisterType((*SessionQueryOutput)(nil), "atomix.multiraft.v1.SessionQueryOutput")
	proto.RegisterType((*CreatePrimitiveInput)(nil), "atomix.multiraft.v1.CreatePrimitiveInput")
	proto.RegisterType((*CreatePrimitiveOutput)(nil), "atomix.multiraft.v1.CreatePrimitiveOutput")
	proto.RegisterType((*ClosePrimitiveInput)(nil), "atomix.multiraft.v1.ClosePrimitiveInput")
	proto.RegisterType((*ClosePrimitiveOutput)(nil), "atomix.multiraft.v1.ClosePrimitiveOutput")
	proto.RegisterType((*PrimitiveProposalInput)(nil), "atomix.multiraft.v1.PrimitiveProposalInput")
	proto.RegisterType((*PrimitiveProposalOutput)(nil), "atomix.multiraft.v1.PrimitiveProposalOutput")
	proto.RegisterType((*PrimitiveQueryInput)(nil), "atomix.multiraft.v1.PrimitiveQueryInput")
	proto.RegisterType((*PrimitiveQueryOutput)(nil), "atomix.multiraft.v1.PrimitiveQueryOutput")
	proto.RegisterType((*Failure)(nil), "atomix.multiraft.v1.Failure")
	proto.RegisterType((*Snapshot)(nil), "atomix.multiraft.v1.Snapshot")
	proto.RegisterType((*PrimitiveSnapshot)(nil), "atomix.multiraft.v1.PrimitiveSnapshot")
	proto.RegisterType((*PrimitiveSpec)(nil), "atomix.multiraft.v1.PrimitiveSpec")
	proto.RegisterType((*SessionSnapshot)(nil), "atomix.multiraft.v1.SessionSnapshot")
	proto.RegisterType((*SessionProposalSnapshot)(nil), "atomix.multiraft.v1.SessionProposalSnapshot")
}

func init() { proto.RegisterFile("atomix/multiraft/v1/fsm.proto", fileDescriptor_9ab16e7f9ceaca8f) }

var fileDescriptor_9ab16e7f9ceaca8f = []byte{
	// 1658 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xbd, 0x73, 0xdb, 0xca,
	0x11, 0x27, 0xf8, 0x21, 0x91, 0x4b, 0x4a, 0x82, 0xce, 0xb4, 0x44, 0x2b, 0x0e, 0xe9, 0x20, 0x1f,
	0x4f, 0xef, 0x25, 0x43, 0xe5, 0xe9, 0xcd, 0xe4, 0xf3, 0x39, 0x36, 0x29, 0x42, 0x16, 0x6c, 0x0a,
	0xa4, 0x8f, 0xa4, 0xed, 0x38, 0x05, 0x07, 0x26, 0x4f, 0x32, 0xc6, 0x24, 0x01, 0x13, 0x80, 0x46,
	0x6a, 0x33, 0x93, 0x99, 0x4c, 0x2a, 0x17, 0x29, 0x12, 0x17, 0x69, 0xf2, 0x5f, 0xa4, 0xcc, 0xa4,
	0x70, 0x95, 0x71, 0x97, 0x54, 0x72, 0x46, 0xfe, 0x07, 0xd2, 0xa4, 0x51, 0x95, 0xb9, 0x3b, 0x00,
	0x24, 0x48, 0x88, 0xa6, 0x2c, 0xbf, 0x0e, 0xb7, 0xd8, 0xdd, 0x5b, 0xfc, 0x76, 0xef, 0xb7, 0xb7,
	0x80, 0x6f, 0x6b, 0xb6, 0xd1, 0xd7, 0x8f, 0xb7, 0xfa, 0x4e, 0xcf, 0xd6, 0x87, 0xda, 0x81, 0xbd,
	0x75, 0xf4, 0xe5, 0xd6, 0x81, 0xd5, 0x2f, 0x9a, 0x43, 0xc3, 0x36, 0xd0, 0x35, 0xfe, 0xba, 0xe8,
	0xbf, 0x2e, 0x1e, 0x7d, 0xb9, 0x91, 0x3f, 0x34, 0x8c, 0xc3, 0x1e, 0xd9, 0x62, 0x2a, 0xcf, 0x9c,
	0x83, 0xad, 0xae, 0x33, 0xd4, 0x6c, 0xdd, 0x18, 0x70, 0xa3, 0x8d, 0xc2, 0xe4, 0x7b, 0x5b, 0xef,
	0x13, 0xcb, 0xd6, 0xfa, 0xa6, 0xab, 0x90, 0x3d, 0x34, 0x0e, 0x0d, 0xf6, 0xb8, 0x45, 0x9f, 0xb8,
	0x54, 0xfa, 0xaf, 0x00, 0x19, 0xac, 0x1d, 0xd8, 0xf5, 0xa1, 0x61, 0x1a, 0x96, 0xd6, 0x43, 0x37,
	0x21, 0x6e, 0x93, 0x61, 0x3f, 0x27, 0xdc, 0x12, 0x36, 0xe3, 0xe5, 0xe4, 0xf9, 0x69, 0x21, 0xde,
	0x24, 0xc3, 0x3e, 0x66, 0x52, 0xb4, 0x0d, 0x19, 0x8b, 0xbc, 0x74, 0xc8, 0xa0, 0x43, 0xda, 0x03,
	0xa7, 0x9f, 0x8b, 0x32, 0xad, 0x95, 0xf3, 0xd3, 0x42, 0xba, 0xe1, 0xca, 0x55, 0xa7, 0x8f, 0xd3,
	0xd6, 0x68, 0x81, 0xca, 0x90, 0xf2, 0x63, 0xc9, 0xc5, 0x6e, 0x09, 0x9b, 0xe9, 0xed, 0x8d, 0x22,
	0x8f, 0xb6, 0xe8, 0x45, 0x5b, 0x6c, 0x7a, 0x1a, 0xe5, 0xe4, 0x9b, 0xd3, 0x42, 0xe4, 0xd5, 0xbb,
	0x82, 0x80, 0x47, 0x66, 0xe8, 0x3e, 0x24, 0x4d, 0x37, 0xc2, 0x5c, 0x9c, 0xb9, 0x28, 0x16, 0x43,
	0x50, 0x2a, 0x36, 0x6c, 0xcd, 0x26, 0xfb, 0x5a, 0xe7, 0xb9, 0x3e, 0x20, 0xde, 0x27, 0x29, 0x03,
	0xd3, 0xb1, 0xb1, 0x6f, 0x2f, 0xfd, 0x33, 0x0a, 0x37, 0x2e, 0xd4, 0x43, 0xf7, 0x21, 0x63, 0x98,
	0x64, 0xd0, 0xb6, 0x88, 0x65, 0xe9, 0xc6, 0x80, 0xe1, 0x90, 0xde, 0xfe, 0x7e, 0xe8, 0x6e, 0x35,
	0x93, 0x0c, 0x1a, 0x5c, 0x8f, 0x19, 0xef, 0x45, 0x70, 0xda, 0x18, 0xc9, 0x50, 0x05, 0xe0, 0x05,
	0x21, 0x66, 0x5b, 0xeb, 0xe9, 0x47, 0x84, 0x61, 0x95, 0xde, 0xfe, 0x6e, 0xa8, 0xa7, 0x07, 0x84,
	0x98, 0x25, 0xaa, 0xe5, 0xf9, 0x49, 0xbd, 0xf0, 0x24, 0x68, 0x1f, 0x96, 0x3a, 0x3d, 0xc3, 0x22,
	0x7e, 0x48, 0x1c, 0xc3, 0x1f, 0x84, 0x3a, 0xda, 0xa1, 0x9a, 0x13, 0x31, 0x65, 0x3a, 0x63, 0x42,
	0x74, 0x6f, 0x0a, 0xca, 0xcf, 0xc3, 0xa1, 0xe4, 0xfa, 0x01, 0x74, 0xf6, 0x22, 0x23, 0x1c, 0xcb,
	0x8b, 0x90, 0xd0, 0xa9, 0x50, 0xfa, 0x5f, 0x14, 0x36, 0xc2, 0x00, 0xad, 0x39, 0x36, 0x45, 0xb4,
	0x40, 0xf5, 0xba, 0xe4, 0xd8, 0x2d, 0xa9, 0xd4, 0xf9, 0x69, 0x21, 0xa1, 0x50, 0x01, 0xe6, 0x72,
	0xf4, 0x60, 0x02, 0xf2, 0xe8, 0x8c, 0xef, 0x1b, 0x83, 0x9c, 0xbb, 0x9f, 0xc4, 0x5c, 0x0e, 0x60,
	0xce, 0xa1, 0xfa, 0xde, 0x6c, 0xcc, 0x7d, 0x47, 0x63, 0xa0, 0xab, 0x93, 0xa0, 0x73, 0xa8, 0x3e,
	0xfb, 0x20, 0xe8, 0xbe, 0xb3, 0x20, 0xea, 0x7b, 0x63, 0xa8, 0x27, 0x98, 0xab, 0x2f, 0xe6, 0x41,
	0xdd, 0xf7, 0x36, 0x82, 0x3d, 0x09, 0x0b, 0x06, 0x93, 0x4a, 0xaf, 0x05, 0x58, 0x1b, 0xc7, 0xfd,
	0xa1, 0x43, 0x86, 0x27, 0xbc, 0x8a, 0x7f, 0x0a, 0xa8, 0xaf, 0x1d, 0xb7, 0x87, 0xa4, 0x43, 0xf4,
	0x23, 0xd2, 0x6d, 0x5f, 0x90, 0x00, 0xb1, 0xaf, 0x1d, 0x63, 0x57, 0x87, 0x49, 0xd0, 0xaf, 0x20,
	0xf1, 0x92, 0xba, 0x99, 0x99, 0x04, 0x37, 0xc8, 0xd1, 0x7e, 0x7b, 0x11, 0xcc, 0xcd, 0x46, 0x45,
	0xf1, 0x3b, 0x01, 0xd6, 0xa7, 0x82, 0x9b, 0xb7, 0x22, 0xee, 0x04, 0xa3, 0xf8, 0xec, 0x83, 0x51,
	0xf8, 0x38, 0xb9, 0x61, 0x8c, 0x40, 0x7a, 0x08, 0xe2, 0xe4, 0x31, 0x45, 0xb7, 0x61, 0x91, 0x52,
	0x8b, 0xe1, 0xd8, 0xee, 0xf1, 0xbe, 0x31, 0xc5, 0x47, 0x15, 0x97, 0x5d, 0x39, 0x1d, 0xfd, 0x89,
	0xd2, 0x91, 0x67, 0x23, 0xa9, 0xb0, 0x3a, 0x55, 0x86, 0xe8, 0xe7, 0x00, 0x6e, 0xa9, 0xb4, 0xf5,
	0xae, 0xfb, 0x61, 0x1b, 0x67, 0xa7, 0x85, 0x94, 0xb7, 0x73, 0xe5, 0x7c, 0x7c, 0x81, 0x53, 0xae,
	0xb6, 0xd2, 0x95, 0xfe, 0x12, 0x83, 0xe5, 0x20, 0x01, 0x5c, 0xc1, 0x1b, 0xfa, 0x0e, 0x64, 0x58,
	0x06, 0xda, 0x07, 0x7a, 0xcf, 0x26, 0x43, 0x06, 0x61, 0x06, 0xa7, 0x99, 0x6c, 0x97, 0x89, 0xd0,
	0x2e, 0xac, 0xf7, 0x34, 0xcb, 0x6e, 0x73, 0xbd, 0x00, 0xa1, 0xc7, 0xc2, 0x09, 0x3d, 0x4b, 0xf5,
	0x59, 0x68, 0x63, 0x52, 0xf4, 0x5a, 0x80, 0x1b, 0xcc, 0x11, 0xc7, 0x3a, 0xe0, 0xc9, 0xca, 0xc5,
	0x6f, 0xc5, 0x36, 0xd3, 0xdb, 0x77, 0xe6, 0xe0, 0xbb, 0x62, 0x55, 0xb3, 0x6c, 0x8e, 0xe3, 0x98,
	0x7b, 0x4b, 0x1e, 0xd8, 0xc3, 0x93, 0x72, 0xfe, 0xb7, 0xef, 0x02, 0xb1, 0xfc, 0x21, 0xb8, 0xc4,
	0x6b, 0xbd, 0x50, 0xe3, 0x0d, 0x05, 0xbe, 0x35, 0xc3, 0x2d, 0x12, 0x21, 0xf6, 0x82, 0x9c, 0x70,
	0x68, 0x31, 0x7d, 0x44, 0x59, 0x48, 0x1c, 0x69, 0x3d, 0x87, 0x13, 0x75, 0x1c, 0xf3, 0xc5, 0x2f,
	0xa2, 0x3f, 0x13, 0xa4, 0x55, 0x58, 0x99, 0x20, 0x0b, 0x5a, 0x03, 0x53, 0x54, 0x7b, 0x95, 0x1a,
	0xc8, 0x02, 0x9a, 0x66, 0x11, 0xe9, 0x1f, 0x31, 0xc8, 0x86, 0xf1, 0xf0, 0x55, 0xea, 0xe3, 0x63,
	0x5a, 0xf8, 0xd7, 0x90, 0xec, 0x12, 0xad, 0xdb, 0xd3, 0x07, 0x64, 0x8e, 0x0e, 0x1e, 0x67, 0xdd,
	0xdb, 0xb7, 0x40, 0x8f, 0x40, 0xec, 0x0c, 0x89, 0x66, 0x93, 0xb6, 0x39, 0xd4, 0xfb, 0xba, 0x4d,
	0x89, 0x79, 0x56, 0xe7, 0xd9, 0x61, 0xca, 0x75, 0x4f, 0xd7, 0x63, 0x98, 0x95, 0x4e, 0x50, 0x8e,
	0x1a, 0xb0, 0xc2, 0x39, 0x7a, 0xe4, 0x96, 0x53, 0xeb, 0xe6, 0xc5, 0x2c, 0x3d, 0xe5, 0x75, 0xb9,
	0x13, 0x10, 0x23, 0x65, 0x8c, 0xa8, 0x17, 0x98, 0xb7, 0x1f, 0x86, 0x7a, 0xf3, 0x2d, 0xe6, 0x68,
	0x90, 0xbf, 0x8f, 0xc1, 0xf5, 0x50, 0x62, 0x9f, 0x4a, 0x86, 0x30, 0x47, 0x32, 0x7e, 0x02, 0x8b,
	0x07, 0x9a, 0xde, 0x73, 0x86, 0xde, 0x95, 0xe2, 0x66, 0x68, 0x80, 0xbb, 0x5c, 0x07, 0x7b, 0xca,
	0xe8, 0x71, 0x48, 0x1a, 0x62, 0x33, 0x5a, 0xd1, 0x44, 0x1a, 0x7c, 0x8a, 0x9d, 0xca, 0x43, 0x73,
	0x3a, 0x0f, 0x33, 0xd3, 0x1b, 0x00, 0xdc, 0x77, 0x3b, 0x99, 0x88, 0xfb, 0x53, 0x1d, 0xf3, 0x47,
	0xf3, 0x25, 0x62, 0x66, 0xcf, 0xfc, 0x97, 0x00, 0xab, 0x53, 0xed, 0xeb, 0x2a, 0xc7, 0x69, 0xfc,
	0x68, 0x44, 0x2f, 0x7d, 0x34, 0xee, 0x7a, 0x8d, 0x2e, 0x36, 0xa3, 0x70, 0xfd, 0x2f, 0x9c, 0xd9,
	0x70, 0xff, 0x2c, 0x00, 0x9a, 0x6e, 0x89, 0xe3, 0xd5, 0x22, 0x5c, 0xa6, 0x5a, 0x4a, 0xc1, 0x16,
	0xfc, 0xf9, 0x1c, 0x91, 0x5d, 0xdc, 0x84, 0x9f, 0x40, 0x36, 0xec, 0x50, 0xa3, 0xbb, 0x10, 0xb7,
	0x4c, 0xd2, 0x71, 0x23, 0x93, 0x66, 0xef, 0xd1, 0x30, 0x49, 0x87, 0xb7, 0xe3, 0xb7, 0xa7, 0x05,
	0x01, 0x33, 0x4b, 0xe9, 0x29, 0x5c, 0x0f, 0xad, 0x53, 0x54, 0x82, 0x8c, 0x5f, 0x8e, 0xa3, 0xa4,
	0xe6, 0xcf, 0x4e, 0x0b, 0xe9, 0x51, 0x10, 0x34, 0xad, 0xe3, 0x4b, 0x9c, 0xf6, 0x6d, 0x94, 0xae,
	0xf4, 0x04, 0xae, 0x85, 0x70, 0xc6, 0xa7, 0xf0, 0xbc, 0x06, 0xd9, 0xb0, 0x53, 0x20, 0x39, 0xb0,
	0x16, 0xce, 0x2b, 0x9f, 0x60, 0x53, 0x94, 0x83, 0x45, 0x53, 0x3b, 0xe9, 0x19, 0x5a, 0xd7, 0xbd,
	0x13, 0x78, 0x4b, 0xe9, 0x2b, 0x58, 0xbf, 0xe0, 0x14, 0x8d, 0x1b, 0x09, 0x41, 0xa3, 0x21, 0x5c,
	0x0b, 0x29, 0xcc, 0x6f, 0x36, 0xd0, 0x1f, 0x43, 0x36, 0xac, 0xe4, 0x66, 0x44, 0xf9, 0xb7, 0x28,
	0x2c, 0xba, 0xb5, 0x8d, 0x7e, 0x09, 0x0b, 0x96, 0xad, 0xd9, 0x8e, 0xc5, 0x94, 0x96, 0x2f, 0x18,
	0xc5, 0x5c, 0x6d, 0x36, 0x4a, 0x3a, 0x16, 0x76, 0x4d, 0xe8, 0x16, 0x7d, 0x62, 0x59, 0xda, 0x21,
	0x3f, 0xe6, 0x29, 0xec, 0x2d, 0x29, 0xa5, 0x2c, 0x70, 0x65, 0x94, 0x86, 0xc5, 0x96, 0xfa, 0x40,
	0xad, 0x3d, 0x56, 0xc5, 0x08, 0x4a, 0x41, 0x42, 0xc6, 0xb8, 0x86, 0x45, 0x01, 0x65, 0x20, 0xb9,
	0x53, 0x52, 0x77, 0xe4, 0xaa, 0x5c, 0x11, 0xa3, 0x68, 0x09, 0x52, 0x6a, 0xad, 0xd9, 0xde, 0xad,
	0xb5, 0xd4, 0x8a, 0x18, 0x43, 0x08, 0x96, 0x4b, 0x55, 0x2c, 0x97, 0x2a, 0xbf, 0x6e, 0xcb, 0x4f,
	0x94, 0x46, 0xb3, 0x21, 0xc6, 0x91, 0x08, 0x99, 0x96, 0x5a, 0x6a, 0x35, 0xf7, 0x6a, 0x58, 0x79,
	0x2a, 0x57, 0xc4, 0x04, 0x35, 0xda, 0xad, 0xe1, 0xb2, 0x52, 0xa9, 0xc8, 0xaa, 0xb8, 0xc0, 0x3c,
	0xd6, 0xd4, 0xdd, 0xaa, 0xb2, 0xd3, 0x14, 0x17, 0xe9, 0xbe, 0x8a, 0xfa, 0xa8, 0x54, 0x55, 0x2a,
	0x62, 0x12, 0xad, 0x40, 0xba, 0xa5, 0x96, 0x1e, 0x95, 0x94, 0x6a, 0xa9, 0x5c, 0x95, 0xc5, 0x14,
	0x5a, 0x85, 0x25, 0xba, 0x5f, 0xa3, 0x55, 0xaf, 0xd7, 0x70, 0x53, 0xae, 0x88, 0x40, 0x0d, 0x9a,
	0xca, 0xbe, 0x5c, 0x6b, 0x35, 0xc5, 0x34, 0x0d, 0x74, 0xb7, 0xd4, 0xaa, 0x36, 0xc5, 0x0c, 0x75,
	0xab, 0xa8, 0x4d, 0x19, 0xab, 0xa5, 0xaa, 0xb8, 0x24, 0x19, 0x90, 0x6c, 0x0c, 0x34, 0xd3, 0x7a,
	0x6e, 0xcc, 0x71, 0x67, 0x0f, 0x8c, 0xf9, 0xd1, 0x8f, 0x1a, 0xf3, 0xa5, 0x3f, 0x0a, 0xb0, 0x3a,
	0x3a, 0xef, 0xde, 0xd6, 0x9f, 0xa0, 0xa4, 0xbe, 0x76, 0x89, 0x26, 0x3a, 0x37, 0xd1, 0xc4, 0x69,
	0x7c, 0x2e, 0xc9, 0xfc, 0x06, 0x96, 0x02, 0x2f, 0x69, 0x31, 0x58, 0x64, 0x78, 0xa4, 0x77, 0x38,
	0xa9, 0xa6, 0xb0, 0xb7, 0x44, 0x37, 0x21, 0x35, 0xd0, 0xfa, 0xc4, 0x32, 0xb5, 0x8e, 0x57, 0x28,
	0x23, 0x01, 0x42, 0x10, 0xa7, 0x0b, 0xc6, 0xf6, 0x29, 0xcc, 0x9e, 0xa5, 0xbf, 0x47, 0x61, 0xc5,
	0xe5, 0x6d, 0xff, 0x8b, 0xaf, 0xd0, 0x8f, 0xee, 0x42, 0x82, 0x56, 0x2c, 0xdf, 0x7c, 0x79, 0xf6,
	0x94, 0xe9, 0xed, 0xc7, 0x7f, 0x9b, 0x60, 0x6e, 0x38, 0x3e, 0x1d, 0xc5, 0x2e, 0x3f, 0x1d, 0xa1,
	0x7b, 0x90, 0x61, 0x33, 0x81, 0x63, 0x76, 0x35, 0x9b, 0x74, 0xdd, 0xab, 0xc0, 0x7c, 0xa5, 0x90,
	0xa6, 0x96, 0x2d, 0x6e, 0x28, 0x7d, 0x01, 0x09, 0x16, 0x57, 0xf0, 0x54, 0x25, 0x21, 0x5e, 0xab,
	0xcb, 0xaa, 0x28, 0x20, 0x80, 0x85, 0x9d, 0x6a, 0xad, 0x41, 0x8f, 0x94, 0xf4, 0xd7, 0x18, 0xac,
	0x4f, 0xdc, 0xb0, 0xe6, 0xaf, 0xdc, 0x3d, 0x48, 0x98, 0xcf, 0x35, 0xcb, 0x83, 0x6c, 0x7b, 0x9e,
	0xc1, 0xdc, 0x87, 0xae, 0x4e, 0x2d, 0x31, 0x77, 0x40, 0xe7, 0x56, 0xd6, 0x8c, 0x5d, 0xe0, 0xe6,
	0xff, 0xb1, 0x82, 0xb9, 0x1d, 0xbd, 0xd2, 0x9a, 0x64, 0xd0, 0xd5, 0x07, 0x87, 0xee, 0x4c, 0xe5,
	0x8d, 0x51, 0x97, 0xf8, 0x5b, 0x80, 0x97, 0x5d, 0x17, 0x7c, 0x69, 0xa1, 0x3d, 0xc8, 0x5d, 0x34,
	0xa5, 0xb1, 0x9b, 0x55, 0xc8, 0x85, 0xf3, 0x7a, 0xe8, 0x50, 0x25, 0xdd, 0x86, 0x04, 0xfb, 0x5e,
	0x9a, 0x92, 0xba, 0xac, 0x56, 0x14, 0xf5, 0x9e, 0x18, 0xa1, 0x0b, 0xdc, 0x52, 0x55, 0xba, 0xe0,
	0x54, 0x57, 0xdb, 0xaf, 0x57, 0xe5, 0xa6, 0x2c, 0x46, 0x03, 0xc4, 0x17, 0x2b, 0xe7, 0xde, 0x9c,
	0xe5, 0x85, 0xb7, 0x67, 0x79, 0xe1, 0x3f, 0x67, 0x79, 0xe1, 0xd5, 0xfb, 0x7c, 0xe4, 0xed, 0xfb,
	0x7c, 0xe4, 0xdf, 0xef, 0xf3, 0x91, 0x67, 0x0b, 0xac, 0x2c, 0xbe, 0xfa, 0x7f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xbd, 0xd3, 0xbf, 0x4e, 0x1a, 0x15, 0x00, 0x00,
}

func (m *RaftProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Proposal != nil {
		{
			size, err := m.Proposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	n2, err2 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintFsm(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x1a
	if m.SequenceNum != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.SequenceNum))
		i--
		dAtA[i] = 0x10
	}
	if m.Term != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StateMachineProposalInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateMachineProposalInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineProposalInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Input != nil {
		{
			size := m.Input.Size()
			i -= size
			if _, err := m.Input.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *StateMachineProposalInput_OpenSession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineProposalInput_OpenSession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OpenSession != nil {
		{
			size, err := m.OpenSession.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *StateMachineProposalInput_KeepAlive) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineProposalInput_KeepAlive) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KeepAlive != nil {
		{
			size, err := m.KeepAlive.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *StateMachineProposalInput_CloseSession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineProposalInput_CloseSession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CloseSession != nil {
		{
			size, err := m.CloseSession.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *StateMachineProposalInput_Proposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineProposalInput_Proposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Proposal != nil {
		{
			size, err := m.Proposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *StateMachineProposalOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateMachineProposalOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineProposalOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Output != nil {
		{
			size := m.Output.Size()
			i -= size
			if _, err := m.Output.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Index != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StateMachineProposalOutput_OpenSession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineProposalOutput_OpenSession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OpenSession != nil {
		{
			size, err := m.OpenSession.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *StateMachineProposalOutput_KeepAlive) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineProposalOutput_KeepAlive) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KeepAlive != nil {
		{
			size, err := m.KeepAlive.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *StateMachineProposalOutput_CloseSession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineProposalOutput_CloseSession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CloseSession != nil {
		{
			size, err := m.CloseSession.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *StateMachineProposalOutput_Proposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineProposalOutput_Proposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Proposal != nil {
		{
			size, err := m.Proposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *StateMachineQueryInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateMachineQueryInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineQueryInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Input != nil {
		{
			size := m.Input.Size()
			i -= size
			if _, err := m.Input.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.MaxReceivedIndex != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.MaxReceivedIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StateMachineQueryInput_Query) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineQueryInput_Query) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *StateMachineQueryOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateMachineQueryOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineQueryOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Output != nil {
		{
			size := m.Output.Size()
			i -= size
			if _, err := m.Output.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Index != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StateMachineQueryOutput_Query) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateMachineQueryOutput_Query) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *OpenSessionInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenSessionInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenSessionInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n13, err13 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.Timeout, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.Timeout):])
	if err13 != nil {
		return 0, err13
	}
	i -= n13
	i = encodeVarintFsm(dAtA, i, uint64(n13))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *OpenSessionOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenSessionOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenSessionOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SessionID != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.SessionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *KeepAliveInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeepAliveInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeepAliveInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LastOutputSequenceNums) > 0 {
		for k := range m.LastOutputSequenceNums {
			v := m.LastOutputSequenceNums[k]
			baseI := i
			i = encodeVarintFsm(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFsm(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFsm(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.LastInputSequenceNum != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.LastInputSequenceNum))
		i--
		dAtA[i] = 0x18
	}
	if len(m.InputFilter) > 0 {
		i -= len(m.InputFilter)
		copy(dAtA[i:], m.InputFilter)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.InputFilter)))
		i--
		dAtA[i] = 0x12
	}
	if m.SessionID != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.SessionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *KeepAliveOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeepAliveOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeepAliveOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CloseSessionInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloseSessionInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloseSessionInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SessionID != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.SessionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CloseSessionOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloseSessionOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloseSessionOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SessionProposalInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionProposalInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionProposalInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Input != nil {
		{
			size := m.Input.Size()
			i -= size
			if _, err := m.Input.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Deadline != nil {
		n14, err14 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Deadline, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Deadline):])
		if err14 != nil {
			return 0, err14
		}
		i -= n14
		i = encodeVarintFsm(dAtA, i, uint64(n14))
		i--
		dAtA[i] = 0x1a
	}
	if m.SequenceNum != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.SequenceNum))
		i--
		dAtA[i] = 0x10
	}
	if m.SessionID != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.SessionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionProposalInput_CreatePrimitive) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionProposalInput_CreatePrimitive) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreatePrimitive != nil {
		{
			size, err := m.CreatePrimitive.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *SessionProposalInput_ClosePrimitive) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionProposalInput_ClosePrimitive) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClosePrimitive != nil {
		{
			size, err := m.ClosePrimitive.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *SessionProposalInput_Proposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionProposalInput_Proposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Proposal != nil {
		{
			size, err := m.Proposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *SessionProposalOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionProposalOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionProposalOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Output != nil {
		{
			size := m.Output.Size()
			i -= size
			if _, err := m.Output.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Failure != nil {
		{
			size, err := m.Failure.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SequenceNum != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.SequenceNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionProposalOutput_CreatePrimitive) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionProposalOutput_CreatePrimitive) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreatePrimitive != nil {
		{
			size, err := m.CreatePrimitive.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SessionProposalOutput_ClosePrimitive) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionProposalOutput_ClosePrimitive) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClosePrimitive != nil {
		{
			size, err := m.ClosePrimitive.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *SessionProposalOutput_Proposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionProposalOutput_Proposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Proposal != nil {
		{
			size, err := m.Proposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *SessionQueryInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionQueryInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Input != nil {
		{
			size := m.Input.Size()
			i -= size
			if _, err := m.Input.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Deadline != nil {
		n22, err22 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Deadline, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Deadline):])
		if err22 != nil {
			return 0, err22
		}
		i -= n22
		i = encodeVarintFsm(dAtA, i, uint64(n22))
		i--
		dAtA[i] = 0x12
	}
	if m.SessionID != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.SessionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionQueryInput_Query) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionQueryInput_Query) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SessionQueryOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionQueryOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Output != nil {
		{
			size := m.Output.Size()
			i -= size
			if _, err := m.Output.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Failure != nil {
		{
			size, err := m.Failure.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SessionQueryOutput_Query) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionQueryOutput_Query) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CreatePrimitiveInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreatePrimitiveInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreatePrimitiveInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PrimitiveSpec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFsm(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CreatePrimitiveOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreatePrimitiveOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreatePrimitiveOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrimitiveID != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.PrimitiveID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClosePrimitiveInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClosePrimitiveInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClosePrimitiveInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrimitiveID != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.PrimitiveID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClosePrimitiveOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClosePrimitiveOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClosePrimitiveOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *PrimitiveProposalInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrimitiveProposalInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrimitiveProposalInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if m.PrimitiveID != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.PrimitiveID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrimitiveProposalOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrimitiveProposalOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrimitiveProposalOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrimitiveQueryInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrimitiveQueryInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrimitiveQueryInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if m.PrimitiveID != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.PrimitiveID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrimitiveQueryOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrimitiveQueryOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrimitiveQueryOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Failure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Failure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Failure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Snapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Snapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Snapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n27, err27 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp):])
	if err27 != nil {
		return 0, err27
	}
	i -= n27
	i = encodeVarintFsm(dAtA, i, uint64(n27))
	i--
	dAtA[i] = 0x12
	if m.Index != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrimitiveSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrimitiveSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrimitiveSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFsm(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.PrimitiveID != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.PrimitiveID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrimitiveSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrimitiveSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrimitiveSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Service) > 0 {
		i -= len(m.Service)
		copy(dAtA[i:], m.Service)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Service)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SessionSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n29, err29 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastUpdated, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastUpdated):])
	if err29 != nil {
		return 0, err29
	}
	i -= n29
	i = encodeVarintFsm(dAtA, i, uint64(n29))
	i--
	dAtA[i] = 0x22
	n30, err30 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.Timeout, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.Timeout):])
	if err30 != nil {
		return 0, err30
	}
	i -= n30
	i = encodeVarintFsm(dAtA, i, uint64(n30))
	i--
	dAtA[i] = 0x1a
	if m.State != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if m.SessionID != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.SessionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionProposalSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionProposalSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionProposalSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastOutputSequenceNum != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.LastOutputSequenceNum))
		i--
		dAtA[i] = 0x28
	}
	if len(m.PendingOutputs) > 0 {
		for iNdEx := len(m.PendingOutputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PendingOutputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFsm(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Input != nil {
		{
			size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Phase != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Phase))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintFsm(dAtA []byte, offset int, v uint64) int {
	offset -= sovFsm(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RaftProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovFsm(uint64(m.Term))
	}
	if m.SequenceNum != 0 {
		n += 1 + sovFsm(uint64(m.SequenceNum))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovFsm(uint64(l))
	if m.Proposal != nil {
		l = m.Proposal.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}

func (m *StateMachineProposalInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Input != nil {
		n += m.Input.Size()
	}
	return n
}

func (m *StateMachineProposalInput_OpenSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OpenSession != nil {
		l = m.OpenSession.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *StateMachineProposalInput_KeepAlive) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeepAlive != nil {
		l = m.KeepAlive.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *StateMachineProposalInput_CloseSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloseSession != nil {
		l = m.CloseSession.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *StateMachineProposalInput_Proposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proposal != nil {
		l = m.Proposal.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *StateMachineProposalOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovFsm(uint64(m.Index))
	}
	if m.Output != nil {
		n += m.Output.Size()
	}
	return n
}

func (m *StateMachineProposalOutput_OpenSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OpenSession != nil {
		l = m.OpenSession.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *StateMachineProposalOutput_KeepAlive) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeepAlive != nil {
		l = m.KeepAlive.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *StateMachineProposalOutput_CloseSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloseSession != nil {
		l = m.CloseSession.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *StateMachineProposalOutput_Proposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proposal != nil {
		l = m.Proposal.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *StateMachineQueryInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxReceivedIndex != 0 {
		n += 1 + sovFsm(uint64(m.MaxReceivedIndex))
	}
	if m.Input != nil {
		n += m.Input.Size()
	}
	return n
}

func (m *StateMachineQueryInput_Query) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *StateMachineQueryOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovFsm(uint64(m.Index))
	}
	if m.Output != nil {
		n += m.Output.Size()
	}
	return n
}

func (m *StateMachineQueryOutput_Query) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *OpenSessionInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.Timeout)
	n += 1 + l + sovFsm(uint64(l))
	return n
}

func (m *OpenSessionOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionID != 0 {
		n += 1 + sovFsm(uint64(m.SessionID))
	}
	return n
}

func (m *KeepAliveInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionID != 0 {
		n += 1 + sovFsm(uint64(m.SessionID))
	}
	l = len(m.InputFilter)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	if m.LastInputSequenceNum != 0 {
		n += 1 + sovFsm(uint64(m.LastInputSequenceNum))
	}
	if len(m.LastOutputSequenceNums) > 0 {
		for k, v := range m.LastOutputSequenceNums {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFsm(uint64(k)) + 1 + sovFsm(uint64(v))
			n += mapEntrySize + 1 + sovFsm(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *KeepAliveOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CloseSessionInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionID != 0 {
		n += 1 + sovFsm(uint64(m.SessionID))
	}
	return n
}

func (m *CloseSessionOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SessionProposalInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionID != 0 {
		n += 1 + sovFsm(uint64(m.SessionID))
	}
	if m.SequenceNum != 0 {
		n += 1 + sovFsm(uint64(m.SequenceNum))
	}
	if m.Deadline != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Deadline)
		n += 1 + l + sovFsm(uint64(l))
	}
	if m.Input != nil {
		n += m.Input.Size()
	}
	return n
}

func (m *SessionProposalInput_CreatePrimitive) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreatePrimitive != nil {
		l = m.CreatePrimitive.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *SessionProposalInput_ClosePrimitive) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClosePrimitive != nil {
		l = m.ClosePrimitive.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *SessionProposalInput_Proposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proposal != nil {
		l = m.Proposal.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *SessionProposalOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SequenceNum != 0 {
		n += 1 + sovFsm(uint64(m.SequenceNum))
	}
	if m.Failure != nil {
		l = m.Failure.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	if m.Output != nil {
		n += m.Output.Size()
	}
	return n
}

func (m *SessionProposalOutput_CreatePrimitive) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreatePrimitive != nil {
		l = m.CreatePrimitive.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *SessionProposalOutput_ClosePrimitive) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClosePrimitive != nil {
		l = m.ClosePrimitive.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *SessionProposalOutput_Proposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proposal != nil {
		l = m.Proposal.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *SessionQueryInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionID != 0 {
		n += 1 + sovFsm(uint64(m.SessionID))
	}
	if m.Deadline != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Deadline)
		n += 1 + l + sovFsm(uint64(l))
	}
	if m.Input != nil {
		n += m.Input.Size()
	}
	return n
}

func (m *SessionQueryInput_Query) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *SessionQueryOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Failure != nil {
		l = m.Failure.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	if m.Output != nil {
		n += m.Output.Size()
	}
	return n
}

func (m *SessionQueryOutput_Query) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *CreatePrimitiveInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.PrimitiveSpec.Size()
	n += 1 + l + sovFsm(uint64(l))
	return n
}

func (m *CreatePrimitiveOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrimitiveID != 0 {
		n += 1 + sovFsm(uint64(m.PrimitiveID))
	}
	return n
}

func (m *ClosePrimitiveInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrimitiveID != 0 {
		n += 1 + sovFsm(uint64(m.PrimitiveID))
	}
	return n
}

func (m *ClosePrimitiveOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *PrimitiveProposalInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrimitiveID != 0 {
		n += 1 + sovFsm(uint64(m.PrimitiveID))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}

func (m *PrimitiveProposalOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}

func (m *PrimitiveQueryInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrimitiveID != 0 {
		n += 1 + sovFsm(uint64(m.PrimitiveID))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}

func (m *PrimitiveQueryOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}

func (m *Failure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovFsm(uint64(m.Status))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}

func (m *Snapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovFsm(uint64(m.Index))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovFsm(uint64(l))
	return n
}

func (m *PrimitiveSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrimitiveID != 0 {
		n += 1 + sovFsm(uint64(m.PrimitiveID))
	}
	l = m.Spec.Size()
	n += 1 + l + sovFsm(uint64(l))
	return n
}

func (m *PrimitiveSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Service)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}

func (m *SessionSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionID != 0 {
		n += 1 + sovFsm(uint64(m.SessionID))
	}
	if m.State != 0 {
		n += 1 + sovFsm(uint64(m.State))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.Timeout)
	n += 1 + l + sovFsm(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastUpdated)
	n += 1 + l + sovFsm(uint64(l))
	return n
}

func (m *SessionProposalSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovFsm(uint64(m.Index))
	}
	if m.Phase != 0 {
		n += 1 + sovFsm(uint64(m.Phase))
	}
	if m.Input != nil {
		l = m.Input.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	if len(m.PendingOutputs) > 0 {
		for _, e := range m.PendingOutputs {
			l = e.Size()
			n += 1 + l + sovFsm(uint64(l))
		}
	}
	if m.LastOutputSequenceNum != 0 {
		n += 1 + sovFsm(uint64(m.LastOutputSequenceNum))
	}
	return n
}

func sovFsm(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFsm(x uint64) (n int) {
	return sovFsm(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RaftProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= Term(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNum", wireType)
			}
			m.SequenceNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNum |= SequenceNum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proposal == nil {
				m.Proposal = &StateMachineProposalInput{}
			}
			if err := m.Proposal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateMachineProposalInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateMachineProposalInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateMachineProposalInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenSession", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OpenSessionInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &StateMachineProposalInput_OpenSession{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepAlive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &KeepAliveInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &StateMachineProposalInput_KeepAlive{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseSession", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CloseSessionInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &StateMachineProposalInput_CloseSession{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SessionProposalInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &StateMachineProposalInput_Proposal{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateMachineProposalOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateMachineProposalOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateMachineProposalOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenSession", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OpenSessionOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &StateMachineProposalOutput_OpenSession{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepAlive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &KeepAliveOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &StateMachineProposalOutput_KeepAlive{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseSession", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CloseSessionOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &StateMachineProposalOutput_CloseSession{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SessionProposalOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &StateMachineProposalOutput_Proposal{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateMachineQueryInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateMachineQueryInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateMachineQueryInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxReceivedIndex", wireType)
			}
			m.MaxReceivedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxReceivedIndex |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SessionQueryInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &StateMachineQueryInput_Query{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateMachineQueryOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateMachineQueryOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateMachineQueryOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SessionQueryOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &StateMachineQueryOutput_Query{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenSessionInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenSessionInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenSessionInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.Timeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenSessionOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenSessionOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenSessionOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			m.SessionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionID |= SessionID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeepAliveInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeepAliveInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeepAliveInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			m.SessionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionID |= SessionID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputFilter", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputFilter = append(m.InputFilter[:0], dAtA[iNdEx:postIndex]...)
			if m.InputFilter == nil {
				m.InputFilter = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastInputSequenceNum", wireType)
			}
			m.LastInputSequenceNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastInputSequenceNum |= SequenceNum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastOutputSequenceNums", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastOutputSequenceNums == nil {
				m.LastOutputSequenceNums = make(map[SequenceNum]SequenceNum)
			}
			var mapkey uint64
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFsm(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFsm
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.LastOutputSequenceNums[SequenceNum(mapkey)] = ((SequenceNum)(mapvalue))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeepAliveOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeepAliveOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeepAliveOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloseSessionInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloseSessionInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloseSessionInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			m.SessionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionID |= SessionID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloseSessionOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloseSessionOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloseSessionOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionProposalInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionProposalInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionProposalInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			m.SessionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionID |= SessionID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNum", wireType)
			}
			m.SequenceNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNum |= SequenceNum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deadline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Deadline == nil {
				m.Deadline = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Deadline, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatePrimitive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreatePrimitiveInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &SessionProposalInput_CreatePrimitive{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosePrimitive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClosePrimitiveInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &SessionProposalInput_ClosePrimitive{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PrimitiveProposalInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &SessionProposalInput_Proposal{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionProposalOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionProposalOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionProposalOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNum", wireType)
			}
			m.SequenceNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNum |= SequenceNum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Failure == nil {
				m.Failure = &Failure{}
			}
			if err := m.Failure.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatePrimitive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreatePrimitiveOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &SessionProposalOutput_CreatePrimitive{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosePrimitive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClosePrimitiveOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &SessionProposalOutput_ClosePrimitive{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PrimitiveProposalOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &SessionProposalOutput_Proposal{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			m.SessionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionID |= SessionID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deadline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Deadline == nil {
				m.Deadline = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Deadline, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PrimitiveQueryInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &SessionQueryInput_Query{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Failure == nil {
				m.Failure = &Failure{}
			}
			if err := m.Failure.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PrimitiveQueryOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &SessionQueryOutput_Query{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreatePrimitiveInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreatePrimitiveInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreatePrimitiveInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimitiveSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrimitiveSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreatePrimitiveOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreatePrimitiveOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreatePrimitiveOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimitiveID", wireType)
			}
			m.PrimitiveID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimitiveID |= PrimitiveID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClosePrimitiveInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClosePrimitiveInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClosePrimitiveInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimitiveID", wireType)
			}
			m.PrimitiveID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimitiveID |= PrimitiveID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClosePrimitiveOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClosePrimitiveOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClosePrimitiveOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimitiveProposalInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimitiveProposalInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimitiveProposalInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimitiveID", wireType)
			}
			m.PrimitiveID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimitiveID |= PrimitiveID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimitiveProposalOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimitiveProposalOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimitiveProposalOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimitiveQueryInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimitiveQueryInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimitiveQueryInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimitiveID", wireType)
			}
			m.PrimitiveID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimitiveID |= PrimitiveID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimitiveQueryOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimitiveQueryOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimitiveQueryOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Failure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Failure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Failure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Failure_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Snapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Snapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimitiveSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimitiveSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimitiveSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimitiveID", wireType)
			}
			m.PrimitiveID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimitiveID |= PrimitiveID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimitiveSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimitiveSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimitiveSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			m.SessionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionID |= SessionID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= SessionSnapshot_State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.Timeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastUpdated, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionProposalSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionProposalSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionProposalSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= SessionProposalSnapshot_Phase(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &SessionProposalInput{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingOutputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PendingOutputs = append(m.PendingOutputs, &SessionProposalOutput{})
			if err := m.PendingOutputs[len(m.PendingOutputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastOutputSequenceNum", wireType)
			}
			m.LastOutputSequenceNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastOutputSequenceNum |= SequenceNum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFsm(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFsm
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFsm
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFsm
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFsm        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFsm          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFsm = fmt.Errorf("proto: unexpected end of group")
)
