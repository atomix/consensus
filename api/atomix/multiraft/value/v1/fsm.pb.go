// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: atomix/multiraft/value/v1/fsm.proto

package v1

import (
	fmt "fmt"
	github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1 "github.com/atomix/multi-raft-storage/api/atomix/multiraft/v1"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ValueState struct {
	Value  *IndexedValue `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Expire *time.Time    `protobuf:"bytes,2,opt,name=expire,proto3,stdtime" json:"expire,omitempty"`
}

func (m *ValueState) Reset()         { *m = ValueState{} }
func (m *ValueState) String() string { return proto.CompactTextString(m) }
func (*ValueState) ProtoMessage()    {}
func (*ValueState) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c2c43731d1a40d7, []int{0}
}
func (m *ValueState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValueState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValueState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValueState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValueState.Merge(m, src)
}
func (m *ValueState) XXX_Size() int {
	return m.Size()
}
func (m *ValueState) XXX_DiscardUnknown() {
	xxx_messageInfo_ValueState.DiscardUnknown(m)
}

var xxx_messageInfo_ValueState proto.InternalMessageInfo

func (m *ValueState) GetValue() *IndexedValue {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *ValueState) GetExpire() *time.Time {
	if m != nil {
		return m.Expire
	}
	return nil
}

type ValueInput struct {
	// Types that are valid to be assigned to Input:
	//	*ValueInput_Get
	//	*ValueInput_Set
	//	*ValueInput_Insert
	//	*ValueInput_Update
	//	*ValueInput_Delete
	//	*ValueInput_Watch
	//	*ValueInput_Events
	Input isValueInput_Input `protobuf_oneof:"input"`
}

func (m *ValueInput) Reset()         { *m = ValueInput{} }
func (m *ValueInput) String() string { return proto.CompactTextString(m) }
func (*ValueInput) ProtoMessage()    {}
func (*ValueInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c2c43731d1a40d7, []int{1}
}
func (m *ValueInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValueInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValueInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValueInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValueInput.Merge(m, src)
}
func (m *ValueInput) XXX_Size() int {
	return m.Size()
}
func (m *ValueInput) XXX_DiscardUnknown() {
	xxx_messageInfo_ValueInput.DiscardUnknown(m)
}

var xxx_messageInfo_ValueInput proto.InternalMessageInfo

type isValueInput_Input interface {
	isValueInput_Input()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ValueInput_Get struct {
	Get *GetInput `protobuf:"bytes,1,opt,name=get,proto3,oneof" json:"get,omitempty"`
}
type ValueInput_Set struct {
	Set *SetInput `protobuf:"bytes,2,opt,name=set,proto3,oneof" json:"set,omitempty"`
}
type ValueInput_Insert struct {
	Insert *InsertInput `protobuf:"bytes,3,opt,name=insert,proto3,oneof" json:"insert,omitempty"`
}
type ValueInput_Update struct {
	Update *UpdateInput `protobuf:"bytes,4,opt,name=update,proto3,oneof" json:"update,omitempty"`
}
type ValueInput_Delete struct {
	Delete *DeleteInput `protobuf:"bytes,5,opt,name=delete,proto3,oneof" json:"delete,omitempty"`
}
type ValueInput_Watch struct {
	Watch *WatchInput `protobuf:"bytes,6,opt,name=watch,proto3,oneof" json:"watch,omitempty"`
}
type ValueInput_Events struct {
	Events *EventsInput `protobuf:"bytes,7,opt,name=events,proto3,oneof" json:"events,omitempty"`
}

func (*ValueInput_Get) isValueInput_Input()    {}
func (*ValueInput_Set) isValueInput_Input()    {}
func (*ValueInput_Insert) isValueInput_Input() {}
func (*ValueInput_Update) isValueInput_Input() {}
func (*ValueInput_Delete) isValueInput_Input() {}
func (*ValueInput_Watch) isValueInput_Input()  {}
func (*ValueInput_Events) isValueInput_Input() {}

func (m *ValueInput) GetInput() isValueInput_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *ValueInput) GetGet() *GetInput {
	if x, ok := m.GetInput().(*ValueInput_Get); ok {
		return x.Get
	}
	return nil
}

func (m *ValueInput) GetSet() *SetInput {
	if x, ok := m.GetInput().(*ValueInput_Set); ok {
		return x.Set
	}
	return nil
}

func (m *ValueInput) GetInsert() *InsertInput {
	if x, ok := m.GetInput().(*ValueInput_Insert); ok {
		return x.Insert
	}
	return nil
}

func (m *ValueInput) GetUpdate() *UpdateInput {
	if x, ok := m.GetInput().(*ValueInput_Update); ok {
		return x.Update
	}
	return nil
}

func (m *ValueInput) GetDelete() *DeleteInput {
	if x, ok := m.GetInput().(*ValueInput_Delete); ok {
		return x.Delete
	}
	return nil
}

func (m *ValueInput) GetWatch() *WatchInput {
	if x, ok := m.GetInput().(*ValueInput_Watch); ok {
		return x.Watch
	}
	return nil
}

func (m *ValueInput) GetEvents() *EventsInput {
	if x, ok := m.GetInput().(*ValueInput_Events); ok {
		return x.Events
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ValueInput) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ValueInput_Get)(nil),
		(*ValueInput_Set)(nil),
		(*ValueInput_Insert)(nil),
		(*ValueInput_Update)(nil),
		(*ValueInput_Delete)(nil),
		(*ValueInput_Watch)(nil),
		(*ValueInput_Events)(nil),
	}
}

type ValueOutput struct {
	// Types that are valid to be assigned to Output:
	//	*ValueOutput_Get
	//	*ValueOutput_Set
	//	*ValueOutput_Insert
	//	*ValueOutput_Update
	//	*ValueOutput_Delete
	//	*ValueOutput_Watch
	//	*ValueOutput_Events
	Output isValueOutput_Output `protobuf_oneof:"output"`
}

func (m *ValueOutput) Reset()         { *m = ValueOutput{} }
func (m *ValueOutput) String() string { return proto.CompactTextString(m) }
func (*ValueOutput) ProtoMessage()    {}
func (*ValueOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c2c43731d1a40d7, []int{2}
}
func (m *ValueOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValueOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValueOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValueOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValueOutput.Merge(m, src)
}
func (m *ValueOutput) XXX_Size() int {
	return m.Size()
}
func (m *ValueOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_ValueOutput.DiscardUnknown(m)
}

var xxx_messageInfo_ValueOutput proto.InternalMessageInfo

type isValueOutput_Output interface {
	isValueOutput_Output()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ValueOutput_Get struct {
	Get *GetOutput `protobuf:"bytes,1,opt,name=get,proto3,oneof" json:"get,omitempty"`
}
type ValueOutput_Set struct {
	Set *SetOutput `protobuf:"bytes,2,opt,name=set,proto3,oneof" json:"set,omitempty"`
}
type ValueOutput_Insert struct {
	Insert *InsertOutput `protobuf:"bytes,3,opt,name=insert,proto3,oneof" json:"insert,omitempty"`
}
type ValueOutput_Update struct {
	Update *UpdateOutput `protobuf:"bytes,4,opt,name=update,proto3,oneof" json:"update,omitempty"`
}
type ValueOutput_Delete struct {
	Delete *DeleteOutput `protobuf:"bytes,5,opt,name=delete,proto3,oneof" json:"delete,omitempty"`
}
type ValueOutput_Watch struct {
	Watch *WatchOutput `protobuf:"bytes,6,opt,name=watch,proto3,oneof" json:"watch,omitempty"`
}
type ValueOutput_Events struct {
	Events *EventsOutput `protobuf:"bytes,7,opt,name=events,proto3,oneof" json:"events,omitempty"`
}

func (*ValueOutput_Get) isValueOutput_Output()    {}
func (*ValueOutput_Set) isValueOutput_Output()    {}
func (*ValueOutput_Insert) isValueOutput_Output() {}
func (*ValueOutput_Update) isValueOutput_Output() {}
func (*ValueOutput_Delete) isValueOutput_Output() {}
func (*ValueOutput_Watch) isValueOutput_Output()  {}
func (*ValueOutput_Events) isValueOutput_Output() {}

func (m *ValueOutput) GetOutput() isValueOutput_Output {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *ValueOutput) GetGet() *GetOutput {
	if x, ok := m.GetOutput().(*ValueOutput_Get); ok {
		return x.Get
	}
	return nil
}

func (m *ValueOutput) GetSet() *SetOutput {
	if x, ok := m.GetOutput().(*ValueOutput_Set); ok {
		return x.Set
	}
	return nil
}

func (m *ValueOutput) GetInsert() *InsertOutput {
	if x, ok := m.GetOutput().(*ValueOutput_Insert); ok {
		return x.Insert
	}
	return nil
}

func (m *ValueOutput) GetUpdate() *UpdateOutput {
	if x, ok := m.GetOutput().(*ValueOutput_Update); ok {
		return x.Update
	}
	return nil
}

func (m *ValueOutput) GetDelete() *DeleteOutput {
	if x, ok := m.GetOutput().(*ValueOutput_Delete); ok {
		return x.Delete
	}
	return nil
}

func (m *ValueOutput) GetWatch() *WatchOutput {
	if x, ok := m.GetOutput().(*ValueOutput_Watch); ok {
		return x.Watch
	}
	return nil
}

func (m *ValueOutput) GetEvents() *EventsOutput {
	if x, ok := m.GetOutput().(*ValueOutput_Events); ok {
		return x.Events
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ValueOutput) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ValueOutput_Get)(nil),
		(*ValueOutput_Set)(nil),
		(*ValueOutput_Insert)(nil),
		(*ValueOutput_Update)(nil),
		(*ValueOutput_Delete)(nil),
		(*ValueOutput_Watch)(nil),
		(*ValueOutput_Events)(nil),
	}
}

type GetInput struct {
}

func (m *GetInput) Reset()         { *m = GetInput{} }
func (m *GetInput) String() string { return proto.CompactTextString(m) }
func (*GetInput) ProtoMessage()    {}
func (*GetInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c2c43731d1a40d7, []int{3}
}
func (m *GetInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetInput.Merge(m, src)
}
func (m *GetInput) XXX_Size() int {
	return m.Size()
}
func (m *GetInput) XXX_DiscardUnknown() {
	xxx_messageInfo_GetInput.DiscardUnknown(m)
}

var xxx_messageInfo_GetInput proto.InternalMessageInfo

type GetOutput struct {
	Value *IndexedValue `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *GetOutput) Reset()         { *m = GetOutput{} }
func (m *GetOutput) String() string { return proto.CompactTextString(m) }
func (*GetOutput) ProtoMessage()    {}
func (*GetOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c2c43731d1a40d7, []int{4}
}
func (m *GetOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetOutput.Merge(m, src)
}
func (m *GetOutput) XXX_Size() int {
	return m.Size()
}
func (m *GetOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_GetOutput.DiscardUnknown(m)
}

var xxx_messageInfo_GetOutput proto.InternalMessageInfo

func (m *GetOutput) GetValue() *IndexedValue {
	if m != nil {
		return m.Value
	}
	return nil
}

type SetInput struct {
	Value []byte         `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	TTL   *time.Duration `protobuf:"bytes,2,opt,name=ttl,proto3,stdduration" json:"ttl,omitempty"`
}

func (m *SetInput) Reset()         { *m = SetInput{} }
func (m *SetInput) String() string { return proto.CompactTextString(m) }
func (*SetInput) ProtoMessage()    {}
func (*SetInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c2c43731d1a40d7, []int{5}
}
func (m *SetInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetInput.Merge(m, src)
}
func (m *SetInput) XXX_Size() int {
	return m.Size()
}
func (m *SetInput) XXX_DiscardUnknown() {
	xxx_messageInfo_SetInput.DiscardUnknown(m)
}

var xxx_messageInfo_SetInput proto.InternalMessageInfo

func (m *SetInput) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *SetInput) GetTTL() *time.Duration {
	if m != nil {
		return m.TTL
	}
	return nil
}

type SetOutput struct {
	Index     github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index `protobuf:"varint,1,opt,name=index,proto3,casttype=github.com/atomix/multi-raft-storage/api/atomix/multiraft/v1.Index" json:"index,omitempty"`
	PrevValue *IndexedValue                                                      `protobuf:"bytes,2,opt,name=prev_value,json=prevValue,proto3" json:"prev_value,omitempty"`
}

func (m *SetOutput) Reset()         { *m = SetOutput{} }
func (m *SetOutput) String() string { return proto.CompactTextString(m) }
func (*SetOutput) ProtoMessage()    {}
func (*SetOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c2c43731d1a40d7, []int{6}
}
func (m *SetOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetOutput.Merge(m, src)
}
func (m *SetOutput) XXX_Size() int {
	return m.Size()
}
func (m *SetOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_SetOutput.DiscardUnknown(m)
}

var xxx_messageInfo_SetOutput proto.InternalMessageInfo

func (m *SetOutput) GetIndex() github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *SetOutput) GetPrevValue() *IndexedValue {
	if m != nil {
		return m.PrevValue
	}
	return nil
}

type InsertInput struct {
	Value []byte         `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	TTL   *time.Duration `protobuf:"bytes,2,opt,name=ttl,proto3,stdduration" json:"ttl,omitempty"`
}

func (m *InsertInput) Reset()         { *m = InsertInput{} }
func (m *InsertInput) String() string { return proto.CompactTextString(m) }
func (*InsertInput) ProtoMessage()    {}
func (*InsertInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c2c43731d1a40d7, []int{7}
}
func (m *InsertInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InsertInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InsertInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InsertInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InsertInput.Merge(m, src)
}
func (m *InsertInput) XXX_Size() int {
	return m.Size()
}
func (m *InsertInput) XXX_DiscardUnknown() {
	xxx_messageInfo_InsertInput.DiscardUnknown(m)
}

var xxx_messageInfo_InsertInput proto.InternalMessageInfo

func (m *InsertInput) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *InsertInput) GetTTL() *time.Duration {
	if m != nil {
		return m.TTL
	}
	return nil
}

type InsertOutput struct {
	Index github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index `protobuf:"varint,1,opt,name=index,proto3,casttype=github.com/atomix/multi-raft-storage/api/atomix/multiraft/v1.Index" json:"index,omitempty"`
}

func (m *InsertOutput) Reset()         { *m = InsertOutput{} }
func (m *InsertOutput) String() string { return proto.CompactTextString(m) }
func (*InsertOutput) ProtoMessage()    {}
func (*InsertOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c2c43731d1a40d7, []int{8}
}
func (m *InsertOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InsertOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InsertOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InsertOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InsertOutput.Merge(m, src)
}
func (m *InsertOutput) XXX_Size() int {
	return m.Size()
}
func (m *InsertOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_InsertOutput.DiscardUnknown(m)
}

var xxx_messageInfo_InsertOutput proto.InternalMessageInfo

func (m *InsertOutput) GetIndex() github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index {
	if m != nil {
		return m.Index
	}
	return 0
}

type UpdateInput struct {
	Value     []byte                                                             `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	PrevIndex github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index `protobuf:"varint,2,opt,name=prev_index,json=prevIndex,proto3,casttype=github.com/atomix/multi-raft-storage/api/atomix/multiraft/v1.Index" json:"prev_index,omitempty"`
	TTL       *time.Duration                                                     `protobuf:"bytes,3,opt,name=ttl,proto3,stdduration" json:"ttl,omitempty"`
}

func (m *UpdateInput) Reset()         { *m = UpdateInput{} }
func (m *UpdateInput) String() string { return proto.CompactTextString(m) }
func (*UpdateInput) ProtoMessage()    {}
func (*UpdateInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c2c43731d1a40d7, []int{9}
}
func (m *UpdateInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateInput.Merge(m, src)
}
func (m *UpdateInput) XXX_Size() int {
	return m.Size()
}
func (m *UpdateInput) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateInput.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateInput proto.InternalMessageInfo

func (m *UpdateInput) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *UpdateInput) GetPrevIndex() github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index {
	if m != nil {
		return m.PrevIndex
	}
	return 0
}

func (m *UpdateInput) GetTTL() *time.Duration {
	if m != nil {
		return m.TTL
	}
	return nil
}

type UpdateOutput struct {
	Index     github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index `protobuf:"varint,1,opt,name=index,proto3,casttype=github.com/atomix/multi-raft-storage/api/atomix/multiraft/v1.Index" json:"index,omitempty"`
	PrevValue IndexedValue                                                       `protobuf:"bytes,2,opt,name=prev_value,json=prevValue,proto3" json:"prev_value"`
}

func (m *UpdateOutput) Reset()         { *m = UpdateOutput{} }
func (m *UpdateOutput) String() string { return proto.CompactTextString(m) }
func (*UpdateOutput) ProtoMessage()    {}
func (*UpdateOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c2c43731d1a40d7, []int{10}
}
func (m *UpdateOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateOutput.Merge(m, src)
}
func (m *UpdateOutput) XXX_Size() int {
	return m.Size()
}
func (m *UpdateOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateOutput.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateOutput proto.InternalMessageInfo

func (m *UpdateOutput) GetIndex() github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *UpdateOutput) GetPrevValue() IndexedValue {
	if m != nil {
		return m.PrevValue
	}
	return IndexedValue{}
}

type DeleteInput struct {
	PrevIndex github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index `protobuf:"varint,1,opt,name=prev_index,json=prevIndex,proto3,casttype=github.com/atomix/multi-raft-storage/api/atomix/multiraft/v1.Index" json:"prev_index,omitempty"`
}

func (m *DeleteInput) Reset()         { *m = DeleteInput{} }
func (m *DeleteInput) String() string { return proto.CompactTextString(m) }
func (*DeleteInput) ProtoMessage()    {}
func (*DeleteInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c2c43731d1a40d7, []int{11}
}
func (m *DeleteInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteInput.Merge(m, src)
}
func (m *DeleteInput) XXX_Size() int {
	return m.Size()
}
func (m *DeleteInput) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteInput.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteInput proto.InternalMessageInfo

func (m *DeleteInput) GetPrevIndex() github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index {
	if m != nil {
		return m.PrevIndex
	}
	return 0
}

type DeleteOutput struct {
	Value IndexedValue `protobuf:"bytes,1,opt,name=value,proto3" json:"value"`
}

func (m *DeleteOutput) Reset()         { *m = DeleteOutput{} }
func (m *DeleteOutput) String() string { return proto.CompactTextString(m) }
func (*DeleteOutput) ProtoMessage()    {}
func (*DeleteOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c2c43731d1a40d7, []int{12}
}
func (m *DeleteOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteOutput.Merge(m, src)
}
func (m *DeleteOutput) XXX_Size() int {
	return m.Size()
}
func (m *DeleteOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteOutput.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteOutput proto.InternalMessageInfo

func (m *DeleteOutput) GetValue() IndexedValue {
	if m != nil {
		return m.Value
	}
	return IndexedValue{}
}

type WatchInput struct {
}

func (m *WatchInput) Reset()         { *m = WatchInput{} }
func (m *WatchInput) String() string { return proto.CompactTextString(m) }
func (*WatchInput) ProtoMessage()    {}
func (*WatchInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c2c43731d1a40d7, []int{13}
}
func (m *WatchInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatchInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatchInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatchInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatchInput.Merge(m, src)
}
func (m *WatchInput) XXX_Size() int {
	return m.Size()
}
func (m *WatchInput) XXX_DiscardUnknown() {
	xxx_messageInfo_WatchInput.DiscardUnknown(m)
}

var xxx_messageInfo_WatchInput proto.InternalMessageInfo

type WatchOutput struct {
	Value *IndexedValue `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *WatchOutput) Reset()         { *m = WatchOutput{} }
func (m *WatchOutput) String() string { return proto.CompactTextString(m) }
func (*WatchOutput) ProtoMessage()    {}
func (*WatchOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c2c43731d1a40d7, []int{14}
}
func (m *WatchOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatchOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatchOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatchOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatchOutput.Merge(m, src)
}
func (m *WatchOutput) XXX_Size() int {
	return m.Size()
}
func (m *WatchOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_WatchOutput.DiscardUnknown(m)
}

var xxx_messageInfo_WatchOutput proto.InternalMessageInfo

func (m *WatchOutput) GetValue() *IndexedValue {
	if m != nil {
		return m.Value
	}
	return nil
}

type EventsInput struct {
}

func (m *EventsInput) Reset()         { *m = EventsInput{} }
func (m *EventsInput) String() string { return proto.CompactTextString(m) }
func (*EventsInput) ProtoMessage()    {}
func (*EventsInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c2c43731d1a40d7, []int{15}
}
func (m *EventsInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventsInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventsInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventsInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventsInput.Merge(m, src)
}
func (m *EventsInput) XXX_Size() int {
	return m.Size()
}
func (m *EventsInput) XXX_DiscardUnknown() {
	xxx_messageInfo_EventsInput.DiscardUnknown(m)
}

var xxx_messageInfo_EventsInput proto.InternalMessageInfo

type EventsOutput struct {
	Event Event `protobuf:"bytes,1,opt,name=event,proto3" json:"event"`
}

func (m *EventsOutput) Reset()         { *m = EventsOutput{} }
func (m *EventsOutput) String() string { return proto.CompactTextString(m) }
func (*EventsOutput) ProtoMessage()    {}
func (*EventsOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c2c43731d1a40d7, []int{16}
}
func (m *EventsOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventsOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventsOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventsOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventsOutput.Merge(m, src)
}
func (m *EventsOutput) XXX_Size() int {
	return m.Size()
}
func (m *EventsOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_EventsOutput.DiscardUnknown(m)
}

var xxx_messageInfo_EventsOutput proto.InternalMessageInfo

func (m *EventsOutput) GetEvent() Event {
	if m != nil {
		return m.Event
	}
	return Event{}
}

type IndexedValue struct {
	Value []byte                                                             `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Index github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index `protobuf:"varint,2,opt,name=index,proto3,casttype=github.com/atomix/multi-raft-storage/api/atomix/multiraft/v1.Index" json:"index,omitempty"`
}

func (m *IndexedValue) Reset()         { *m = IndexedValue{} }
func (m *IndexedValue) String() string { return proto.CompactTextString(m) }
func (*IndexedValue) ProtoMessage()    {}
func (*IndexedValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c2c43731d1a40d7, []int{17}
}
func (m *IndexedValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexedValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexedValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexedValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexedValue.Merge(m, src)
}
func (m *IndexedValue) XXX_Size() int {
	return m.Size()
}
func (m *IndexedValue) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexedValue.DiscardUnknown(m)
}

var xxx_messageInfo_IndexedValue proto.InternalMessageInfo

func (m *IndexedValue) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *IndexedValue) GetIndex() github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index {
	if m != nil {
		return m.Index
	}
	return 0
}

type Event struct {
	// Types that are valid to be assigned to Event:
	//	*Event_Created_
	//	*Event_Updated_
	//	*Event_Deleted_
	Event isEvent_Event `protobuf_oneof:"event"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c2c43731d1a40d7, []int{18}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

type isEvent_Event interface {
	isEvent_Event()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Event_Created_ struct {
	Created *Event_Created `protobuf:"bytes,1,opt,name=created,proto3,oneof" json:"created,omitempty"`
}
type Event_Updated_ struct {
	Updated *Event_Updated `protobuf:"bytes,2,opt,name=updated,proto3,oneof" json:"updated,omitempty"`
}
type Event_Deleted_ struct {
	Deleted *Event_Deleted `protobuf:"bytes,3,opt,name=deleted,proto3,oneof" json:"deleted,omitempty"`
}

func (*Event_Created_) isEvent_Event() {}
func (*Event_Updated_) isEvent_Event() {}
func (*Event_Deleted_) isEvent_Event() {}

func (m *Event) GetEvent() isEvent_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *Event) GetCreated() *Event_Created {
	if x, ok := m.GetEvent().(*Event_Created_); ok {
		return x.Created
	}
	return nil
}

func (m *Event) GetUpdated() *Event_Updated {
	if x, ok := m.GetEvent().(*Event_Updated_); ok {
		return x.Updated
	}
	return nil
}

func (m *Event) GetDeleted() *Event_Deleted {
	if x, ok := m.GetEvent().(*Event_Deleted_); ok {
		return x.Deleted
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Event) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Event_Created_)(nil),
		(*Event_Updated_)(nil),
		(*Event_Deleted_)(nil),
	}
}

type Event_Created struct {
	Value IndexedValue `protobuf:"bytes,1,opt,name=value,proto3" json:"value"`
}

func (m *Event_Created) Reset()         { *m = Event_Created{} }
func (m *Event_Created) String() string { return proto.CompactTextString(m) }
func (*Event_Created) ProtoMessage()    {}
func (*Event_Created) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c2c43731d1a40d7, []int{18, 0}
}
func (m *Event_Created) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event_Created) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event_Created.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event_Created) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event_Created.Merge(m, src)
}
func (m *Event_Created) XXX_Size() int {
	return m.Size()
}
func (m *Event_Created) XXX_DiscardUnknown() {
	xxx_messageInfo_Event_Created.DiscardUnknown(m)
}

var xxx_messageInfo_Event_Created proto.InternalMessageInfo

func (m *Event_Created) GetValue() IndexedValue {
	if m != nil {
		return m.Value
	}
	return IndexedValue{}
}

type Event_Updated struct {
	Value     IndexedValue `protobuf:"bytes,1,opt,name=value,proto3" json:"value"`
	PrevValue IndexedValue `protobuf:"bytes,2,opt,name=prev_value,json=prevValue,proto3" json:"prev_value"`
}

func (m *Event_Updated) Reset()         { *m = Event_Updated{} }
func (m *Event_Updated) String() string { return proto.CompactTextString(m) }
func (*Event_Updated) ProtoMessage()    {}
func (*Event_Updated) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c2c43731d1a40d7, []int{18, 1}
}
func (m *Event_Updated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event_Updated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event_Updated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event_Updated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event_Updated.Merge(m, src)
}
func (m *Event_Updated) XXX_Size() int {
	return m.Size()
}
func (m *Event_Updated) XXX_DiscardUnknown() {
	xxx_messageInfo_Event_Updated.DiscardUnknown(m)
}

var xxx_messageInfo_Event_Updated proto.InternalMessageInfo

func (m *Event_Updated) GetValue() IndexedValue {
	if m != nil {
		return m.Value
	}
	return IndexedValue{}
}

func (m *Event_Updated) GetPrevValue() IndexedValue {
	if m != nil {
		return m.PrevValue
	}
	return IndexedValue{}
}

type Event_Deleted struct {
	Value   IndexedValue `protobuf:"bytes,1,opt,name=value,proto3" json:"value"`
	Expired bool         `protobuf:"varint,2,opt,name=expired,proto3" json:"expired,omitempty"`
}

func (m *Event_Deleted) Reset()         { *m = Event_Deleted{} }
func (m *Event_Deleted) String() string { return proto.CompactTextString(m) }
func (*Event_Deleted) ProtoMessage()    {}
func (*Event_Deleted) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c2c43731d1a40d7, []int{18, 2}
}
func (m *Event_Deleted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event_Deleted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event_Deleted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event_Deleted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event_Deleted.Merge(m, src)
}
func (m *Event_Deleted) XXX_Size() int {
	return m.Size()
}
func (m *Event_Deleted) XXX_DiscardUnknown() {
	xxx_messageInfo_Event_Deleted.DiscardUnknown(m)
}

var xxx_messageInfo_Event_Deleted proto.InternalMessageInfo

func (m *Event_Deleted) GetValue() IndexedValue {
	if m != nil {
		return m.Value
	}
	return IndexedValue{}
}

func (m *Event_Deleted) GetExpired() bool {
	if m != nil {
		return m.Expired
	}
	return false
}

func init() {
	proto.RegisterType((*ValueState)(nil), "atomix.multiraft.value.v1.ValueState")
	proto.RegisterType((*ValueInput)(nil), "atomix.multiraft.value.v1.ValueInput")
	proto.RegisterType((*ValueOutput)(nil), "atomix.multiraft.value.v1.ValueOutput")
	proto.RegisterType((*GetInput)(nil), "atomix.multiraft.value.v1.GetInput")
	proto.RegisterType((*GetOutput)(nil), "atomix.multiraft.value.v1.GetOutput")
	proto.RegisterType((*SetInput)(nil), "atomix.multiraft.value.v1.SetInput")
	proto.RegisterType((*SetOutput)(nil), "atomix.multiraft.value.v1.SetOutput")
	proto.RegisterType((*InsertInput)(nil), "atomix.multiraft.value.v1.InsertInput")
	proto.RegisterType((*InsertOutput)(nil), "atomix.multiraft.value.v1.InsertOutput")
	proto.RegisterType((*UpdateInput)(nil), "atomix.multiraft.value.v1.UpdateInput")
	proto.RegisterType((*UpdateOutput)(nil), "atomix.multiraft.value.v1.UpdateOutput")
	proto.RegisterType((*DeleteInput)(nil), "atomix.multiraft.value.v1.DeleteInput")
	proto.RegisterType((*DeleteOutput)(nil), "atomix.multiraft.value.v1.DeleteOutput")
	proto.RegisterType((*WatchInput)(nil), "atomix.multiraft.value.v1.WatchInput")
	proto.RegisterType((*WatchOutput)(nil), "atomix.multiraft.value.v1.WatchOutput")
	proto.RegisterType((*EventsInput)(nil), "atomix.multiraft.value.v1.EventsInput")
	proto.RegisterType((*EventsOutput)(nil), "atomix.multiraft.value.v1.EventsOutput")
	proto.RegisterType((*IndexedValue)(nil), "atomix.multiraft.value.v1.IndexedValue")
	proto.RegisterType((*Event)(nil), "atomix.multiraft.value.v1.Event")
	proto.RegisterType((*Event_Created)(nil), "atomix.multiraft.value.v1.Event.Created")
	proto.RegisterType((*Event_Updated)(nil), "atomix.multiraft.value.v1.Event.Updated")
	proto.RegisterType((*Event_Deleted)(nil), "atomix.multiraft.value.v1.Event.Deleted")
}

func init() {
	proto.RegisterFile("atomix/multiraft/value/v1/fsm.proto", fileDescriptor_3c2c43731d1a40d7)
}

var fileDescriptor_3c2c43731d1a40d7 = []byte{
	// 851 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x3f, 0x6f, 0xd3, 0x5e,
	0x14, 0x8d, 0xf3, 0xbf, 0xd7, 0xf9, 0x2d, 0x56, 0x07, 0x37, 0x43, 0x52, 0xb9, 0xfd, 0x35, 0x5d,
	0x6a, 0xab, 0x30, 0xd0, 0x01, 0x10, 0x49, 0x4b, 0x69, 0x51, 0x04, 0x52, 0x5a, 0x40, 0x42, 0x20,
	0xe4, 0xd6, 0xaf, 0xae, 0xa5, 0x24, 0xb6, 0xec, 0xe7, 0x90, 0x19, 0x89, 0xbd, 0x23, 0x03, 0x5f,
	0x82, 0x15, 0x56, 0x86, 0x4e, 0xa8, 0x1b, 0x4c, 0x05, 0xa5, 0xdf, 0x82, 0x09, 0xbd, 0x3f, 0xb6,
	0x1f, 0xa9, 0x1a, 0xab, 0x34, 0xd9, 0x5c, 0xf7, 0x9e, 0xe3, 0xf3, 0xee, 0xb9, 0xf7, 0xbc, 0xc0,
	0x92, 0x89, 0xdd, 0x9e, 0x33, 0x34, 0x7a, 0x61, 0x17, 0x3b, 0xbe, 0x79, 0x84, 0x8d, 0x81, 0xd9,
	0x0d, 0x91, 0x31, 0x58, 0x37, 0x8e, 0x82, 0x9e, 0xee, 0xf9, 0x2e, 0x76, 0x95, 0x05, 0x56, 0xa4,
	0xc7, 0x45, 0x3a, 0x2d, 0xd2, 0x07, 0xeb, 0xd5, 0x9a, 0xed, 0xba, 0x76, 0x17, 0x19, 0xb4, 0xf0,
	0x20, 0x3c, 0x32, 0xac, 0xd0, 0x37, 0xb1, 0xe3, 0xf6, 0x19, 0xb4, 0x5a, 0x1f, 0xff, 0x3f, 0x76,
	0x7a, 0x28, 0xc0, 0x66, 0xcf, 0xe3, 0x05, 0xf3, 0xb6, 0x6b, 0xbb, 0xf4, 0xd1, 0x20, 0x4f, 0xec,
	0xad, 0xf6, 0x5e, 0x02, 0x78, 0x4e, 0xbe, 0xb1, 0x87, 0x4d, 0x8c, 0x94, 0x7b, 0x50, 0xa0, 0x5f,
	0x54, 0xa5, 0x45, 0x69, 0x55, 0xbe, 0xd5, 0xd0, 0xaf, 0x14, 0xa4, 0xef, 0xf6, 0x2d, 0x34, 0x44,
	0x16, 0x05, 0x77, 0x18, 0x4a, 0xd9, 0x80, 0x22, 0x1a, 0x7a, 0x8e, 0x8f, 0xd4, 0x2c, 0xc5, 0x57,
	0x75, 0xa6, 0x4a, 0x8f, 0x54, 0xe9, 0xfb, 0x91, 0xaa, 0x56, 0xfe, 0xe4, 0x67, 0x5d, 0xea, 0xf0,
	0x7a, 0xed, 0x5b, 0x8e, 0xeb, 0xd8, 0xed, 0x7b, 0x21, 0x56, 0xee, 0x40, 0xce, 0x46, 0x98, 0xab,
	0x58, 0x9a, 0xa0, 0xe2, 0x11, 0xc2, 0x14, 0xb1, 0x93, 0xe9, 0x10, 0x04, 0x01, 0x06, 0x08, 0xf3,
	0xcf, 0x4f, 0x02, 0xee, 0x09, 0xc0, 0x00, 0x61, 0xe5, 0x01, 0x14, 0x9d, 0x7e, 0x80, 0x7c, 0xac,
	0xe6, 0x28, 0x76, 0x65, 0xe2, 0xd1, 0x49, 0x61, 0x04, 0xe7, 0x38, 0xc2, 0x10, 0x7a, 0x96, 0x89,
	0x91, 0x9a, 0x4f, 0x65, 0x78, 0x46, 0x0b, 0x63, 0x06, 0x86, 0x23, 0x0c, 0x16, 0xea, 0x22, 0x8c,
	0xd4, 0x42, 0x2a, 0xc3, 0x16, 0x2d, 0x8c, 0x19, 0x18, 0x8e, 0xf8, 0xf7, 0xd6, 0xc4, 0x87, 0xc7,
	0x6a, 0x91, 0x12, 0xfc, 0x3f, 0x81, 0xe0, 0x05, 0xa9, 0x8b, 0xf0, 0x0c, 0x45, 0x04, 0xa0, 0x01,
	0xea, 0xe3, 0x40, 0x2d, 0xa5, 0x0a, 0x78, 0x48, 0x0b, 0x63, 0x01, 0x0c, 0xd7, 0x2a, 0x41, 0xc1,
	0x21, 0xaf, 0xb4, 0xef, 0x39, 0x90, 0xa9, 0xa1, 0x4f, 0x43, 0x4c, 0x1c, 0xdd, 0x10, 0x1d, 0x5d,
	0x9e, 0xec, 0x28, 0x83, 0x44, 0x96, 0x6e, 0x88, 0x96, 0x2e, 0x4f, 0xb6, 0x34, 0x41, 0x12, 0x4f,
	0x9b, 0x63, 0x9e, 0x36, 0x52, 0x3d, 0x8d, 0xf1, 0x91, 0xa9, 0xcd, 0x31, 0x53, 0x1b, 0xa9, 0xa6,
	0x26, 0x14, 0xdc, 0xd5, 0xe6, 0x98, 0xab, 0x8d, 0x54, 0x57, 0x13, 0x0a, 0x6e, 0xeb, 0xfd, 0xbf,
	0x6d, 0x5d, 0x49, 0xb3, 0x35, 0x26, 0xe0, 0xbe, 0x36, 0xc7, 0x7c, 0x6d, 0xa4, 0xfa, 0x9a, 0x48,
	0xe0, 0xc6, 0x96, 0xa1, 0xe8, 0xd2, 0x77, 0x1a, 0x40, 0x39, 0xda, 0x3a, 0xed, 0x31, 0xcc, 0xc5,
	0x7e, 0xdd, 0x30, 0x3c, 0xb4, 0x97, 0x50, 0x8e, 0x96, 0x52, 0x99, 0x17, 0xa9, 0x2a, 0x49, 0xbc,
	0xe4, 0x30, 0xee, 0xf2, 0x49, 0x58, 0xb8, 0x94, 0x2d, 0x5b, 0x3c, 0x11, 0x5b, 0xf2, 0xe8, 0xbc,
	0x9e, 0xdb, 0xdf, 0x6f, 0x7f, 0x20, 0x09, 0x43, 0x20, 0xda, 0x27, 0x09, 0xe6, 0xe2, 0xf1, 0x50,
	0x5e, 0x91, 0x21, 0xb5, 0xd0, 0x90, 0xb2, 0xe7, 0x5b, 0xdb, 0xbf, 0xcf, 0xeb, 0x2d, 0xdb, 0xc1,
	0xc7, 0xe1, 0x81, 0x7e, 0xe8, 0xf6, 0x0c, 0x31, 0xa9, 0xd7, 0x88, 0xee, 0xb5, 0x00, 0xbb, 0xbe,
	0x69, 0x23, 0xc3, 0xf4, 0x1c, 0xe3, 0x72, 0x8e, 0xf3, 0xe3, 0x74, 0x18, 0xa9, 0xb2, 0x0d, 0xe0,
	0xf9, 0x68, 0xf0, 0x86, 0x1d, 0x20, 0x7b, 0xbd, 0x5e, 0xcc, 0x11, 0x28, 0x7d, 0xd4, 0x5e, 0x83,
	0x2c, 0x04, 0xcd, 0xd4, 0x5b, 0xd2, 0x85, 0x8a, 0x38, 0xf3, 0xb3, 0x6d, 0x8a, 0xf6, 0x55, 0x02,
	0x59, 0x08, 0xbd, 0x2b, 0x4e, 0x83, 0x78, 0xeb, 0x98, 0x90, 0xec, 0x54, 0x85, 0xd0, 0xce, 0xd2,
	0xc7, 0xa8, 0x69, 0xb9, 0xeb, 0x37, 0xed, 0xb3, 0x04, 0x15, 0x71, 0xcd, 0x67, 0x3c, 0x4a, 0xed,
	0x1b, 0x8c, 0x52, 0x2b, 0x7f, 0x7a, 0x5e, 0xcf, 0x88, 0x03, 0x85, 0x41, 0x16, 0x6e, 0x8d, 0xb1,
	0x66, 0x4b, 0x33, 0x6a, 0xb6, 0xb6, 0x07, 0x15, 0x31, 0xd5, 0x94, 0xcd, 0x7f, 0x4b, 0x09, 0x7e,
	0x1c, 0x9e, 0x15, 0x15, 0x80, 0xe4, 0xfe, 0xd2, 0xda, 0x20, 0x0b, 0xb1, 0x77, 0xd3, 0x1c, 0xfa,
	0x0f, 0x64, 0xe1, 0x6e, 0xd3, 0xda, 0x50, 0x11, 0x23, 0x51, 0xb9, 0x0b, 0x05, 0x1a, 0x89, 0x9c,
	0x7d, 0x31, 0x2d, 0x4a, 0x23, 0xe1, 0x14, 0xa4, 0xbd, 0x93, 0xc8, 0xda, 0x25, 0x1f, 0xbd, 0x62,
	0x11, 0xe2, 0xb1, 0xca, 0xce, 0x62, 0x19, 0xbf, 0xe4, 0xa1, 0x40, 0xb5, 0x29, 0x5b, 0x50, 0x3a,
	0xf4, 0x91, 0x89, 0x91, 0xc5, 0x8f, 0xb3, 0x9a, 0x76, 0x1c, 0x7d, 0x93, 0xd5, 0xef, 0x64, 0x3a,
	0x11, 0x94, 0xb0, 0xb0, 0xbb, 0xce, 0xe2, 0x33, 0x9a, 0xce, 0xc2, 0x96, 0x88, 0xb2, 0x70, 0x28,
	0x61, 0x61, 0xd7, 0x9d, 0xc5, 0x37, 0x33, 0x9d, 0x85, 0x0d, 0x16, 0x65, 0xe1, 0xd0, 0xea, 0x13,
	0x28, 0x71, 0x85, 0x53, 0x99, 0xb4, 0xea, 0x47, 0x09, 0x4a, 0x5c, 0xec, 0x54, 0x08, 0xa7, 0xbb,
	0xd3, 0xd5, 0x63, 0x28, 0xf1, 0x26, 0x4c, 0x47, 0x9d, 0x0a, 0x25, 0xf6, 0x8b, 0x9c, 0x59, 0x59,
	0xee, 0x44, 0x7f, 0x92, 0x5f, 0x76, 0x74, 0x84, 0x5b, 0xea, 0xe9, 0xa8, 0x26, 0x9d, 0x8d, 0x6a,
	0xd2, 0xaf, 0x51, 0x4d, 0x3a, 0xb9, 0xa8, 0x65, 0xce, 0x2e, 0x6a, 0x99, 0x1f, 0x17, 0xb5, 0xcc,
	0x41, 0x91, 0x46, 0xe8, 0xed, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x9d, 0x3c, 0x09, 0x9c, 0xec,
	0x0c, 0x00, 0x00,
}

func (m *ValueState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValueState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Expire != nil {
		n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Expire, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expire):])
		if err1 != nil {
			return 0, err1
		}
		i -= n1
		i = encodeVarintFsm(dAtA, i, uint64(n1))
		i--
		dAtA[i] = 0x12
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValueInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValueInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Input != nil {
		{
			size := m.Input.Size()
			i -= size
			if _, err := m.Input.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ValueInput_Get) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueInput_Get) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Get != nil {
		{
			size, err := m.Get.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ValueInput_Set) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueInput_Set) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Set != nil {
		{
			size, err := m.Set.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ValueInput_Insert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueInput_Insert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Insert != nil {
		{
			size, err := m.Insert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ValueInput_Update) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueInput_Update) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Update != nil {
		{
			size, err := m.Update.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ValueInput_Delete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueInput_Delete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Delete != nil {
		{
			size, err := m.Delete.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ValueInput_Watch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueInput_Watch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Watch != nil {
		{
			size, err := m.Watch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *ValueInput_Events) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueInput_Events) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Events != nil {
		{
			size, err := m.Events.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *ValueOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValueOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Output != nil {
		{
			size := m.Output.Size()
			i -= size
			if _, err := m.Output.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ValueOutput_Get) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueOutput_Get) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Get != nil {
		{
			size, err := m.Get.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ValueOutput_Set) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueOutput_Set) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Set != nil {
		{
			size, err := m.Set.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ValueOutput_Insert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueOutput_Insert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Insert != nil {
		{
			size, err := m.Insert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ValueOutput_Update) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueOutput_Update) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Update != nil {
		{
			size, err := m.Update.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ValueOutput_Delete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueOutput_Delete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Delete != nil {
		{
			size, err := m.Delete.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ValueOutput_Watch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueOutput_Watch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Watch != nil {
		{
			size, err := m.Watch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *ValueOutput_Events) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueOutput_Events) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Events != nil {
		{
			size, err := m.Events.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *GetInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TTL != nil {
		n18, err18 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.TTL, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TTL):])
		if err18 != nil {
			return 0, err18
		}
		i -= n18
		i = encodeVarintFsm(dAtA, i, uint64(n18))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrevValue != nil {
		{
			size, err := m.PrevValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Index != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InsertInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsertInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InsertInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TTL != nil {
		n20, err20 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.TTL, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TTL):])
		if err20 != nil {
			return 0, err20
		}
		i -= n20
		i = encodeVarintFsm(dAtA, i, uint64(n20))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InsertOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsertOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InsertOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TTL != nil {
		n21, err21 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.TTL, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TTL):])
		if err21 != nil {
			return 0, err21
		}
		i -= n21
		i = encodeVarintFsm(dAtA, i, uint64(n21))
		i--
		dAtA[i] = 0x1a
	}
	if m.PrevIndex != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.PrevIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PrevValue.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFsm(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Index != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrevIndex != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.PrevIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFsm(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *WatchInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatchInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *WatchOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatchOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventsInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventsInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventsInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *EventsOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventsOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventsOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Event.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFsm(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IndexedValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexedValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexedValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Event != nil {
		{
			size := m.Event.Size()
			i -= size
			if _, err := m.Event.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Event_Created_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_Created_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Created != nil {
		{
			size, err := m.Created.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Event_Updated_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_Updated_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Updated != nil {
		{
			size, err := m.Updated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Event_Deleted_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_Deleted_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Deleted != nil {
		{
			size, err := m.Deleted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Event_Created) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event_Created) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_Created) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFsm(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Event_Updated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event_Updated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_Updated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PrevValue.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFsm(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFsm(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Event_Deleted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event_Deleted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_Deleted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Expired {
		i--
		if m.Expired {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFsm(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintFsm(dAtA []byte, offset int, v uint64) int {
	offset -= sovFsm(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ValueState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	if m.Expire != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expire)
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}

func (m *ValueInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Input != nil {
		n += m.Input.Size()
	}
	return n
}

func (m *ValueInput_Get) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Get != nil {
		l = m.Get.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *ValueInput_Set) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Set != nil {
		l = m.Set.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *ValueInput_Insert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Insert != nil {
		l = m.Insert.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *ValueInput_Update) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Update != nil {
		l = m.Update.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *ValueInput_Delete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delete != nil {
		l = m.Delete.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *ValueInput_Watch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Watch != nil {
		l = m.Watch.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *ValueInput_Events) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Events != nil {
		l = m.Events.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *ValueOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		n += m.Output.Size()
	}
	return n
}

func (m *ValueOutput_Get) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Get != nil {
		l = m.Get.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *ValueOutput_Set) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Set != nil {
		l = m.Set.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *ValueOutput_Insert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Insert != nil {
		l = m.Insert.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *ValueOutput_Update) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Update != nil {
		l = m.Update.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *ValueOutput_Delete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delete != nil {
		l = m.Delete.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *ValueOutput_Watch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Watch != nil {
		l = m.Watch.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *ValueOutput_Events) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Events != nil {
		l = m.Events.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *GetInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}

func (m *SetInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	if m.TTL != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TTL)
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}

func (m *SetOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovFsm(uint64(m.Index))
	}
	if m.PrevValue != nil {
		l = m.PrevValue.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}

func (m *InsertInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	if m.TTL != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TTL)
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}

func (m *InsertOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovFsm(uint64(m.Index))
	}
	return n
}

func (m *UpdateInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	if m.PrevIndex != 0 {
		n += 1 + sovFsm(uint64(m.PrevIndex))
	}
	if m.TTL != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TTL)
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}

func (m *UpdateOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovFsm(uint64(m.Index))
	}
	l = m.PrevValue.Size()
	n += 1 + l + sovFsm(uint64(l))
	return n
}

func (m *DeleteInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrevIndex != 0 {
		n += 1 + sovFsm(uint64(m.PrevIndex))
	}
	return n
}

func (m *DeleteOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Value.Size()
	n += 1 + l + sovFsm(uint64(l))
	return n
}

func (m *WatchInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *WatchOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}

func (m *EventsInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *EventsOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Event.Size()
	n += 1 + l + sovFsm(uint64(l))
	return n
}

func (m *IndexedValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovFsm(uint64(m.Index))
	}
	return n
}

func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != nil {
		n += m.Event.Size()
	}
	return n
}

func (m *Event_Created_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Created != nil {
		l = m.Created.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *Event_Updated_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Updated != nil {
		l = m.Updated.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *Event_Deleted_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Deleted != nil {
		l = m.Deleted.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *Event_Created) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Value.Size()
	n += 1 + l + sovFsm(uint64(l))
	return n
}

func (m *Event_Updated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Value.Size()
	n += 1 + l + sovFsm(uint64(l))
	l = m.PrevValue.Size()
	n += 1 + l + sovFsm(uint64(l))
	return n
}

func (m *Event_Deleted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Value.Size()
	n += 1 + l + sovFsm(uint64(l))
	if m.Expired {
		n += 2
	}
	return n
}

func sovFsm(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFsm(x uint64) (n int) {
	return sovFsm(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ValueState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &IndexedValue{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expire == nil {
				m.Expire = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Expire, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValueInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Get", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &ValueInput_Get{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SetInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &ValueInput_Set{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Insert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InsertInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &ValueInput_Insert{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UpdateInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &ValueInput_Update{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &ValueInput_Delete{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Watch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WatchInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &ValueInput_Watch{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EventsInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &ValueInput_Events{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValueOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Get", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &ValueOutput_Get{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SetOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &ValueOutput_Set{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Insert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InsertOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &ValueOutput_Insert{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UpdateOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &ValueOutput_Update{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &ValueOutput_Delete{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Watch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WatchOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &ValueOutput_Watch{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EventsOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &ValueOutput_Events{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &IndexedValue{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TTL == nil {
				m.TTL = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.TTL, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrevValue == nil {
				m.PrevValue = &IndexedValue{}
			}
			if err := m.PrevValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsertInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TTL == nil {
				m.TTL = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.TTL, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsertOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevIndex", wireType)
			}
			m.PrevIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevIndex |= github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TTL == nil {
				m.TTL = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.TTL, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrevValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevIndex", wireType)
			}
			m.PrevIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevIndex |= github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &IndexedValue{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventsInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventsInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventsInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventsOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventsOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventsOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexedValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexedValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexedValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Event_Created{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &Event_Created_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Event_Updated{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &Event_Updated_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deleted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Event_Deleted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &Event_Deleted_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event_Created) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Created: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Created: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event_Updated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Updated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Updated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrevValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event_Deleted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deleted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deleted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expired", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Expired = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFsm(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFsm
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFsm
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFsm
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFsm        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFsm          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFsm = fmt.Errorf("proto: unexpected end of group")
)
