// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: atomix/multiraft/atomic/countermap/v1/fsm.proto

package v1

import (
	fmt "fmt"
	github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1 "github.com/atomix/multi-raft-storage/api/atomix/multiraft/v1"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AtomicCounterMapListener struct {
	Index github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index `protobuf:"varint,1,opt,name=index,proto3,casttype=github.com/atomix/multi-raft-storage/api/atomix/multiraft/v1.Index" json:"index,omitempty"`
	Key   string                                                             `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *AtomicCounterMapListener) Reset()         { *m = AtomicCounterMapListener{} }
func (m *AtomicCounterMapListener) String() string { return proto.CompactTextString(m) }
func (*AtomicCounterMapListener) ProtoMessage()    {}
func (*AtomicCounterMapListener) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{0}
}
func (m *AtomicCounterMapListener) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AtomicCounterMapListener) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AtomicCounterMapListener.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AtomicCounterMapListener) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AtomicCounterMapListener.Merge(m, src)
}
func (m *AtomicCounterMapListener) XXX_Size() int {
	return m.Size()
}
func (m *AtomicCounterMapListener) XXX_DiscardUnknown() {
	xxx_messageInfo_AtomicCounterMapListener.DiscardUnknown(m)
}

var xxx_messageInfo_AtomicCounterMapListener proto.InternalMessageInfo

func (m *AtomicCounterMapListener) GetIndex() github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *AtomicCounterMapListener) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type AtomicCounterMapEntry struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value int64  `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *AtomicCounterMapEntry) Reset()         { *m = AtomicCounterMapEntry{} }
func (m *AtomicCounterMapEntry) String() string { return proto.CompactTextString(m) }
func (*AtomicCounterMapEntry) ProtoMessage()    {}
func (*AtomicCounterMapEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{1}
}
func (m *AtomicCounterMapEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AtomicCounterMapEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AtomicCounterMapEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AtomicCounterMapEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AtomicCounterMapEntry.Merge(m, src)
}
func (m *AtomicCounterMapEntry) XXX_Size() int {
	return m.Size()
}
func (m *AtomicCounterMapEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_AtomicCounterMapEntry.DiscardUnknown(m)
}

var xxx_messageInfo_AtomicCounterMapEntry proto.InternalMessageInfo

func (m *AtomicCounterMapEntry) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *AtomicCounterMapEntry) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type AtomicCounterMapInput struct {
	// Types that are valid to be assigned to Input:
	//	*AtomicCounterMapInput_Size_
	//	*AtomicCounterMapInput_Insert
	//	*AtomicCounterMapInput_Update
	//	*AtomicCounterMapInput_Increment
	//	*AtomicCounterMapInput_Decrement
	//	*AtomicCounterMapInput_Get
	//	*AtomicCounterMapInput_Remove
	//	*AtomicCounterMapInput_Clear
	//	*AtomicCounterMapInput_Lock
	//	*AtomicCounterMapInput_Unlock
	//	*AtomicCounterMapInput_Entries
	//	*AtomicCounterMapInput_Events
	Input isAtomicCounterMapInput_Input `protobuf_oneof:"input"`
}

func (m *AtomicCounterMapInput) Reset()         { *m = AtomicCounterMapInput{} }
func (m *AtomicCounterMapInput) String() string { return proto.CompactTextString(m) }
func (*AtomicCounterMapInput) ProtoMessage()    {}
func (*AtomicCounterMapInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{2}
}
func (m *AtomicCounterMapInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AtomicCounterMapInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AtomicCounterMapInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AtomicCounterMapInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AtomicCounterMapInput.Merge(m, src)
}
func (m *AtomicCounterMapInput) XXX_Size() int {
	return m.Size()
}
func (m *AtomicCounterMapInput) XXX_DiscardUnknown() {
	xxx_messageInfo_AtomicCounterMapInput.DiscardUnknown(m)
}

var xxx_messageInfo_AtomicCounterMapInput proto.InternalMessageInfo

type isAtomicCounterMapInput_Input interface {
	isAtomicCounterMapInput_Input()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AtomicCounterMapInput_Size_ struct {
	Size_ *SizeInput `protobuf:"bytes,1,opt,name=size,proto3,oneof" json:"size,omitempty"`
}
type AtomicCounterMapInput_Insert struct {
	Insert *InsertInput `protobuf:"bytes,3,opt,name=insert,proto3,oneof" json:"insert,omitempty"`
}
type AtomicCounterMapInput_Update struct {
	Update *UpdateInput `protobuf:"bytes,4,opt,name=update,proto3,oneof" json:"update,omitempty"`
}
type AtomicCounterMapInput_Increment struct {
	Increment *IncrementInput `protobuf:"bytes,5,opt,name=increment,proto3,oneof" json:"increment,omitempty"`
}
type AtomicCounterMapInput_Decrement struct {
	Decrement *DecrementInput `protobuf:"bytes,6,opt,name=decrement,proto3,oneof" json:"decrement,omitempty"`
}
type AtomicCounterMapInput_Get struct {
	Get *GetInput `protobuf:"bytes,7,opt,name=get,proto3,oneof" json:"get,omitempty"`
}
type AtomicCounterMapInput_Remove struct {
	Remove *RemoveInput `protobuf:"bytes,8,opt,name=remove,proto3,oneof" json:"remove,omitempty"`
}
type AtomicCounterMapInput_Clear struct {
	Clear *ClearInput `protobuf:"bytes,9,opt,name=clear,proto3,oneof" json:"clear,omitempty"`
}
type AtomicCounterMapInput_Lock struct {
	Lock *LockInput `protobuf:"bytes,10,opt,name=lock,proto3,oneof" json:"lock,omitempty"`
}
type AtomicCounterMapInput_Unlock struct {
	Unlock *UnlockInput `protobuf:"bytes,11,opt,name=unlock,proto3,oneof" json:"unlock,omitempty"`
}
type AtomicCounterMapInput_Entries struct {
	Entries *EntriesInput `protobuf:"bytes,12,opt,name=entries,proto3,oneof" json:"entries,omitempty"`
}
type AtomicCounterMapInput_Events struct {
	Events *EventsInput `protobuf:"bytes,13,opt,name=events,proto3,oneof" json:"events,omitempty"`
}

func (*AtomicCounterMapInput_Size_) isAtomicCounterMapInput_Input()     {}
func (*AtomicCounterMapInput_Insert) isAtomicCounterMapInput_Input()    {}
func (*AtomicCounterMapInput_Update) isAtomicCounterMapInput_Input()    {}
func (*AtomicCounterMapInput_Increment) isAtomicCounterMapInput_Input() {}
func (*AtomicCounterMapInput_Decrement) isAtomicCounterMapInput_Input() {}
func (*AtomicCounterMapInput_Get) isAtomicCounterMapInput_Input()       {}
func (*AtomicCounterMapInput_Remove) isAtomicCounterMapInput_Input()    {}
func (*AtomicCounterMapInput_Clear) isAtomicCounterMapInput_Input()     {}
func (*AtomicCounterMapInput_Lock) isAtomicCounterMapInput_Input()      {}
func (*AtomicCounterMapInput_Unlock) isAtomicCounterMapInput_Input()    {}
func (*AtomicCounterMapInput_Entries) isAtomicCounterMapInput_Input()   {}
func (*AtomicCounterMapInput_Events) isAtomicCounterMapInput_Input()    {}

func (m *AtomicCounterMapInput) GetInput() isAtomicCounterMapInput_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *AtomicCounterMapInput) GetSize_() *SizeInput {
	if x, ok := m.GetInput().(*AtomicCounterMapInput_Size_); ok {
		return x.Size_
	}
	return nil
}

func (m *AtomicCounterMapInput) GetInsert() *InsertInput {
	if x, ok := m.GetInput().(*AtomicCounterMapInput_Insert); ok {
		return x.Insert
	}
	return nil
}

func (m *AtomicCounterMapInput) GetUpdate() *UpdateInput {
	if x, ok := m.GetInput().(*AtomicCounterMapInput_Update); ok {
		return x.Update
	}
	return nil
}

func (m *AtomicCounterMapInput) GetIncrement() *IncrementInput {
	if x, ok := m.GetInput().(*AtomicCounterMapInput_Increment); ok {
		return x.Increment
	}
	return nil
}

func (m *AtomicCounterMapInput) GetDecrement() *DecrementInput {
	if x, ok := m.GetInput().(*AtomicCounterMapInput_Decrement); ok {
		return x.Decrement
	}
	return nil
}

func (m *AtomicCounterMapInput) GetGet() *GetInput {
	if x, ok := m.GetInput().(*AtomicCounterMapInput_Get); ok {
		return x.Get
	}
	return nil
}

func (m *AtomicCounterMapInput) GetRemove() *RemoveInput {
	if x, ok := m.GetInput().(*AtomicCounterMapInput_Remove); ok {
		return x.Remove
	}
	return nil
}

func (m *AtomicCounterMapInput) GetClear() *ClearInput {
	if x, ok := m.GetInput().(*AtomicCounterMapInput_Clear); ok {
		return x.Clear
	}
	return nil
}

func (m *AtomicCounterMapInput) GetLock() *LockInput {
	if x, ok := m.GetInput().(*AtomicCounterMapInput_Lock); ok {
		return x.Lock
	}
	return nil
}

func (m *AtomicCounterMapInput) GetUnlock() *UnlockInput {
	if x, ok := m.GetInput().(*AtomicCounterMapInput_Unlock); ok {
		return x.Unlock
	}
	return nil
}

func (m *AtomicCounterMapInput) GetEntries() *EntriesInput {
	if x, ok := m.GetInput().(*AtomicCounterMapInput_Entries); ok {
		return x.Entries
	}
	return nil
}

func (m *AtomicCounterMapInput) GetEvents() *EventsInput {
	if x, ok := m.GetInput().(*AtomicCounterMapInput_Events); ok {
		return x.Events
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AtomicCounterMapInput) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AtomicCounterMapInput_Size_)(nil),
		(*AtomicCounterMapInput_Insert)(nil),
		(*AtomicCounterMapInput_Update)(nil),
		(*AtomicCounterMapInput_Increment)(nil),
		(*AtomicCounterMapInput_Decrement)(nil),
		(*AtomicCounterMapInput_Get)(nil),
		(*AtomicCounterMapInput_Remove)(nil),
		(*AtomicCounterMapInput_Clear)(nil),
		(*AtomicCounterMapInput_Lock)(nil),
		(*AtomicCounterMapInput_Unlock)(nil),
		(*AtomicCounterMapInput_Entries)(nil),
		(*AtomicCounterMapInput_Events)(nil),
	}
}

type AtomicCounterMapOutput struct {
	// Types that are valid to be assigned to Output:
	//	*AtomicCounterMapOutput_Size_
	//	*AtomicCounterMapOutput_Insert
	//	*AtomicCounterMapOutput_Update
	//	*AtomicCounterMapOutput_Increment
	//	*AtomicCounterMapOutput_Decrement
	//	*AtomicCounterMapOutput_Get
	//	*AtomicCounterMapOutput_Remove
	//	*AtomicCounterMapOutput_Clear
	//	*AtomicCounterMapOutput_Lock
	//	*AtomicCounterMapOutput_Unlock
	//	*AtomicCounterMapOutput_Entries
	//	*AtomicCounterMapOutput_Events
	Output isAtomicCounterMapOutput_Output `protobuf_oneof:"output"`
}

func (m *AtomicCounterMapOutput) Reset()         { *m = AtomicCounterMapOutput{} }
func (m *AtomicCounterMapOutput) String() string { return proto.CompactTextString(m) }
func (*AtomicCounterMapOutput) ProtoMessage()    {}
func (*AtomicCounterMapOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{3}
}
func (m *AtomicCounterMapOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AtomicCounterMapOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AtomicCounterMapOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AtomicCounterMapOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AtomicCounterMapOutput.Merge(m, src)
}
func (m *AtomicCounterMapOutput) XXX_Size() int {
	return m.Size()
}
func (m *AtomicCounterMapOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_AtomicCounterMapOutput.DiscardUnknown(m)
}

var xxx_messageInfo_AtomicCounterMapOutput proto.InternalMessageInfo

type isAtomicCounterMapOutput_Output interface {
	isAtomicCounterMapOutput_Output()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AtomicCounterMapOutput_Size_ struct {
	Size_ *SizeOutput `protobuf:"bytes,1,opt,name=size,proto3,oneof" json:"size,omitempty"`
}
type AtomicCounterMapOutput_Insert struct {
	Insert *InsertOutput `protobuf:"bytes,3,opt,name=insert,proto3,oneof" json:"insert,omitempty"`
}
type AtomicCounterMapOutput_Update struct {
	Update *UpdateOutput `protobuf:"bytes,4,opt,name=update,proto3,oneof" json:"update,omitempty"`
}
type AtomicCounterMapOutput_Increment struct {
	Increment *IncrementOutput `protobuf:"bytes,5,opt,name=increment,proto3,oneof" json:"increment,omitempty"`
}
type AtomicCounterMapOutput_Decrement struct {
	Decrement *DecrementOutput `protobuf:"bytes,6,opt,name=decrement,proto3,oneof" json:"decrement,omitempty"`
}
type AtomicCounterMapOutput_Get struct {
	Get *GetOutput `protobuf:"bytes,7,opt,name=get,proto3,oneof" json:"get,omitempty"`
}
type AtomicCounterMapOutput_Remove struct {
	Remove *RemoveOutput `protobuf:"bytes,8,opt,name=remove,proto3,oneof" json:"remove,omitempty"`
}
type AtomicCounterMapOutput_Clear struct {
	Clear *ClearOutput `protobuf:"bytes,9,opt,name=clear,proto3,oneof" json:"clear,omitempty"`
}
type AtomicCounterMapOutput_Lock struct {
	Lock *LockOutput `protobuf:"bytes,10,opt,name=lock,proto3,oneof" json:"lock,omitempty"`
}
type AtomicCounterMapOutput_Unlock struct {
	Unlock *UnlockOutput `protobuf:"bytes,11,opt,name=unlock,proto3,oneof" json:"unlock,omitempty"`
}
type AtomicCounterMapOutput_Entries struct {
	Entries *EntriesOutput `protobuf:"bytes,12,opt,name=entries,proto3,oneof" json:"entries,omitempty"`
}
type AtomicCounterMapOutput_Events struct {
	Events *EventsOutput `protobuf:"bytes,13,opt,name=events,proto3,oneof" json:"events,omitempty"`
}

func (*AtomicCounterMapOutput_Size_) isAtomicCounterMapOutput_Output()     {}
func (*AtomicCounterMapOutput_Insert) isAtomicCounterMapOutput_Output()    {}
func (*AtomicCounterMapOutput_Update) isAtomicCounterMapOutput_Output()    {}
func (*AtomicCounterMapOutput_Increment) isAtomicCounterMapOutput_Output() {}
func (*AtomicCounterMapOutput_Decrement) isAtomicCounterMapOutput_Output() {}
func (*AtomicCounterMapOutput_Get) isAtomicCounterMapOutput_Output()       {}
func (*AtomicCounterMapOutput_Remove) isAtomicCounterMapOutput_Output()    {}
func (*AtomicCounterMapOutput_Clear) isAtomicCounterMapOutput_Output()     {}
func (*AtomicCounterMapOutput_Lock) isAtomicCounterMapOutput_Output()      {}
func (*AtomicCounterMapOutput_Unlock) isAtomicCounterMapOutput_Output()    {}
func (*AtomicCounterMapOutput_Entries) isAtomicCounterMapOutput_Output()   {}
func (*AtomicCounterMapOutput_Events) isAtomicCounterMapOutput_Output()    {}

func (m *AtomicCounterMapOutput) GetOutput() isAtomicCounterMapOutput_Output {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *AtomicCounterMapOutput) GetSize_() *SizeOutput {
	if x, ok := m.GetOutput().(*AtomicCounterMapOutput_Size_); ok {
		return x.Size_
	}
	return nil
}

func (m *AtomicCounterMapOutput) GetInsert() *InsertOutput {
	if x, ok := m.GetOutput().(*AtomicCounterMapOutput_Insert); ok {
		return x.Insert
	}
	return nil
}

func (m *AtomicCounterMapOutput) GetUpdate() *UpdateOutput {
	if x, ok := m.GetOutput().(*AtomicCounterMapOutput_Update); ok {
		return x.Update
	}
	return nil
}

func (m *AtomicCounterMapOutput) GetIncrement() *IncrementOutput {
	if x, ok := m.GetOutput().(*AtomicCounterMapOutput_Increment); ok {
		return x.Increment
	}
	return nil
}

func (m *AtomicCounterMapOutput) GetDecrement() *DecrementOutput {
	if x, ok := m.GetOutput().(*AtomicCounterMapOutput_Decrement); ok {
		return x.Decrement
	}
	return nil
}

func (m *AtomicCounterMapOutput) GetGet() *GetOutput {
	if x, ok := m.GetOutput().(*AtomicCounterMapOutput_Get); ok {
		return x.Get
	}
	return nil
}

func (m *AtomicCounterMapOutput) GetRemove() *RemoveOutput {
	if x, ok := m.GetOutput().(*AtomicCounterMapOutput_Remove); ok {
		return x.Remove
	}
	return nil
}

func (m *AtomicCounterMapOutput) GetClear() *ClearOutput {
	if x, ok := m.GetOutput().(*AtomicCounterMapOutput_Clear); ok {
		return x.Clear
	}
	return nil
}

func (m *AtomicCounterMapOutput) GetLock() *LockOutput {
	if x, ok := m.GetOutput().(*AtomicCounterMapOutput_Lock); ok {
		return x.Lock
	}
	return nil
}

func (m *AtomicCounterMapOutput) GetUnlock() *UnlockOutput {
	if x, ok := m.GetOutput().(*AtomicCounterMapOutput_Unlock); ok {
		return x.Unlock
	}
	return nil
}

func (m *AtomicCounterMapOutput) GetEntries() *EntriesOutput {
	if x, ok := m.GetOutput().(*AtomicCounterMapOutput_Entries); ok {
		return x.Entries
	}
	return nil
}

func (m *AtomicCounterMapOutput) GetEvents() *EventsOutput {
	if x, ok := m.GetOutput().(*AtomicCounterMapOutput_Events); ok {
		return x.Events
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AtomicCounterMapOutput) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AtomicCounterMapOutput_Size_)(nil),
		(*AtomicCounterMapOutput_Insert)(nil),
		(*AtomicCounterMapOutput_Update)(nil),
		(*AtomicCounterMapOutput_Increment)(nil),
		(*AtomicCounterMapOutput_Decrement)(nil),
		(*AtomicCounterMapOutput_Get)(nil),
		(*AtomicCounterMapOutput_Remove)(nil),
		(*AtomicCounterMapOutput_Clear)(nil),
		(*AtomicCounterMapOutput_Lock)(nil),
		(*AtomicCounterMapOutput_Unlock)(nil),
		(*AtomicCounterMapOutput_Entries)(nil),
		(*AtomicCounterMapOutput_Events)(nil),
	}
}

type SizeInput struct {
}

func (m *SizeInput) Reset()         { *m = SizeInput{} }
func (m *SizeInput) String() string { return proto.CompactTextString(m) }
func (*SizeInput) ProtoMessage()    {}
func (*SizeInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{4}
}
func (m *SizeInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SizeInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SizeInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SizeInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SizeInput.Merge(m, src)
}
func (m *SizeInput) XXX_Size() int {
	return m.Size()
}
func (m *SizeInput) XXX_DiscardUnknown() {
	xxx_messageInfo_SizeInput.DiscardUnknown(m)
}

var xxx_messageInfo_SizeInput proto.InternalMessageInfo

type SizeOutput struct {
	Size_ uint32 `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
}

func (m *SizeOutput) Reset()         { *m = SizeOutput{} }
func (m *SizeOutput) String() string { return proto.CompactTextString(m) }
func (*SizeOutput) ProtoMessage()    {}
func (*SizeOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{5}
}
func (m *SizeOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SizeOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SizeOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SizeOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SizeOutput.Merge(m, src)
}
func (m *SizeOutput) XXX_Size() int {
	return m.Size()
}
func (m *SizeOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_SizeOutput.DiscardUnknown(m)
}

var xxx_messageInfo_SizeOutput proto.InternalMessageInfo

func (m *SizeOutput) GetSize_() uint32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

type SetInput struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value int64  `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *SetInput) Reset()         { *m = SetInput{} }
func (m *SetInput) String() string { return proto.CompactTextString(m) }
func (*SetInput) ProtoMessage()    {}
func (*SetInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{6}
}
func (m *SetInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetInput.Merge(m, src)
}
func (m *SetInput) XXX_Size() int {
	return m.Size()
}
func (m *SetInput) XXX_DiscardUnknown() {
	xxx_messageInfo_SetInput.DiscardUnknown(m)
}

var xxx_messageInfo_SetInput proto.InternalMessageInfo

func (m *SetInput) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SetInput) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type SetOutput struct {
	PrevValue int64 `protobuf:"varint,1,opt,name=prev_value,json=prevValue,proto3" json:"prev_value,omitempty"`
}

func (m *SetOutput) Reset()         { *m = SetOutput{} }
func (m *SetOutput) String() string { return proto.CompactTextString(m) }
func (*SetOutput) ProtoMessage()    {}
func (*SetOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{7}
}
func (m *SetOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetOutput.Merge(m, src)
}
func (m *SetOutput) XXX_Size() int {
	return m.Size()
}
func (m *SetOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_SetOutput.DiscardUnknown(m)
}

var xxx_messageInfo_SetOutput proto.InternalMessageInfo

func (m *SetOutput) GetPrevValue() int64 {
	if m != nil {
		return m.PrevValue
	}
	return 0
}

type InsertInput struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value int64  `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *InsertInput) Reset()         { *m = InsertInput{} }
func (m *InsertInput) String() string { return proto.CompactTextString(m) }
func (*InsertInput) ProtoMessage()    {}
func (*InsertInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{8}
}
func (m *InsertInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InsertInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InsertInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InsertInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InsertInput.Merge(m, src)
}
func (m *InsertInput) XXX_Size() int {
	return m.Size()
}
func (m *InsertInput) XXX_DiscardUnknown() {
	xxx_messageInfo_InsertInput.DiscardUnknown(m)
}

var xxx_messageInfo_InsertInput proto.InternalMessageInfo

func (m *InsertInput) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *InsertInput) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type InsertOutput struct {
}

func (m *InsertOutput) Reset()         { *m = InsertOutput{} }
func (m *InsertOutput) String() string { return proto.CompactTextString(m) }
func (*InsertOutput) ProtoMessage()    {}
func (*InsertOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{9}
}
func (m *InsertOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InsertOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InsertOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InsertOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InsertOutput.Merge(m, src)
}
func (m *InsertOutput) XXX_Size() int {
	return m.Size()
}
func (m *InsertOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_InsertOutput.DiscardUnknown(m)
}

var xxx_messageInfo_InsertOutput proto.InternalMessageInfo

type UpdateInput struct {
	Key       string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value     int64  `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
	PrevValue int64  `protobuf:"varint,3,opt,name=prev_value,json=prevValue,proto3" json:"prev_value,omitempty"`
}

func (m *UpdateInput) Reset()         { *m = UpdateInput{} }
func (m *UpdateInput) String() string { return proto.CompactTextString(m) }
func (*UpdateInput) ProtoMessage()    {}
func (*UpdateInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{10}
}
func (m *UpdateInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateInput.Merge(m, src)
}
func (m *UpdateInput) XXX_Size() int {
	return m.Size()
}
func (m *UpdateInput) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateInput.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateInput proto.InternalMessageInfo

func (m *UpdateInput) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *UpdateInput) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *UpdateInput) GetPrevValue() int64 {
	if m != nil {
		return m.PrevValue
	}
	return 0
}

type UpdateOutput struct {
	PrevValue int64 `protobuf:"varint,1,opt,name=prev_value,json=prevValue,proto3" json:"prev_value,omitempty"`
}

func (m *UpdateOutput) Reset()         { *m = UpdateOutput{} }
func (m *UpdateOutput) String() string { return proto.CompactTextString(m) }
func (*UpdateOutput) ProtoMessage()    {}
func (*UpdateOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{11}
}
func (m *UpdateOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateOutput.Merge(m, src)
}
func (m *UpdateOutput) XXX_Size() int {
	return m.Size()
}
func (m *UpdateOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateOutput.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateOutput proto.InternalMessageInfo

func (m *UpdateOutput) GetPrevValue() int64 {
	if m != nil {
		return m.PrevValue
	}
	return 0
}

type IncrementInput struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Delta int64  `protobuf:"varint,2,opt,name=delta,proto3" json:"delta,omitempty"`
}

func (m *IncrementInput) Reset()         { *m = IncrementInput{} }
func (m *IncrementInput) String() string { return proto.CompactTextString(m) }
func (*IncrementInput) ProtoMessage()    {}
func (*IncrementInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{12}
}
func (m *IncrementInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncrementInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IncrementInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IncrementInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncrementInput.Merge(m, src)
}
func (m *IncrementInput) XXX_Size() int {
	return m.Size()
}
func (m *IncrementInput) XXX_DiscardUnknown() {
	xxx_messageInfo_IncrementInput.DiscardUnknown(m)
}

var xxx_messageInfo_IncrementInput proto.InternalMessageInfo

func (m *IncrementInput) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *IncrementInput) GetDelta() int64 {
	if m != nil {
		return m.Delta
	}
	return 0
}

type IncrementOutput struct {
	PrevValue int64 `protobuf:"varint,1,opt,name=prev_value,json=prevValue,proto3" json:"prev_value,omitempty"`
}

func (m *IncrementOutput) Reset()         { *m = IncrementOutput{} }
func (m *IncrementOutput) String() string { return proto.CompactTextString(m) }
func (*IncrementOutput) ProtoMessage()    {}
func (*IncrementOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{13}
}
func (m *IncrementOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncrementOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IncrementOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IncrementOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncrementOutput.Merge(m, src)
}
func (m *IncrementOutput) XXX_Size() int {
	return m.Size()
}
func (m *IncrementOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_IncrementOutput.DiscardUnknown(m)
}

var xxx_messageInfo_IncrementOutput proto.InternalMessageInfo

func (m *IncrementOutput) GetPrevValue() int64 {
	if m != nil {
		return m.PrevValue
	}
	return 0
}

type DecrementInput struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Delta int64  `protobuf:"varint,2,opt,name=delta,proto3" json:"delta,omitempty"`
}

func (m *DecrementInput) Reset()         { *m = DecrementInput{} }
func (m *DecrementInput) String() string { return proto.CompactTextString(m) }
func (*DecrementInput) ProtoMessage()    {}
func (*DecrementInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{14}
}
func (m *DecrementInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecrementInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecrementInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DecrementInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecrementInput.Merge(m, src)
}
func (m *DecrementInput) XXX_Size() int {
	return m.Size()
}
func (m *DecrementInput) XXX_DiscardUnknown() {
	xxx_messageInfo_DecrementInput.DiscardUnknown(m)
}

var xxx_messageInfo_DecrementInput proto.InternalMessageInfo

func (m *DecrementInput) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *DecrementInput) GetDelta() int64 {
	if m != nil {
		return m.Delta
	}
	return 0
}

type DecrementOutput struct {
	PrevValue int64 `protobuf:"varint,1,opt,name=prev_value,json=prevValue,proto3" json:"prev_value,omitempty"`
}

func (m *DecrementOutput) Reset()         { *m = DecrementOutput{} }
func (m *DecrementOutput) String() string { return proto.CompactTextString(m) }
func (*DecrementOutput) ProtoMessage()    {}
func (*DecrementOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{15}
}
func (m *DecrementOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecrementOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecrementOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DecrementOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecrementOutput.Merge(m, src)
}
func (m *DecrementOutput) XXX_Size() int {
	return m.Size()
}
func (m *DecrementOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_DecrementOutput.DiscardUnknown(m)
}

var xxx_messageInfo_DecrementOutput proto.InternalMessageInfo

func (m *DecrementOutput) GetPrevValue() int64 {
	if m != nil {
		return m.PrevValue
	}
	return 0
}

type GetInput struct {
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *GetInput) Reset()         { *m = GetInput{} }
func (m *GetInput) String() string { return proto.CompactTextString(m) }
func (*GetInput) ProtoMessage()    {}
func (*GetInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{16}
}
func (m *GetInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetInput.Merge(m, src)
}
func (m *GetInput) XXX_Size() int {
	return m.Size()
}
func (m *GetInput) XXX_DiscardUnknown() {
	xxx_messageInfo_GetInput.DiscardUnknown(m)
}

var xxx_messageInfo_GetInput proto.InternalMessageInfo

func (m *GetInput) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type GetOutput struct {
	Value int64 `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *GetOutput) Reset()         { *m = GetOutput{} }
func (m *GetOutput) String() string { return proto.CompactTextString(m) }
func (*GetOutput) ProtoMessage()    {}
func (*GetOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{17}
}
func (m *GetOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetOutput.Merge(m, src)
}
func (m *GetOutput) XXX_Size() int {
	return m.Size()
}
func (m *GetOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_GetOutput.DiscardUnknown(m)
}

var xxx_messageInfo_GetOutput proto.InternalMessageInfo

func (m *GetOutput) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type RemoveInput struct {
	Key       string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	PrevValue int64  `protobuf:"varint,3,opt,name=prev_value,json=prevValue,proto3" json:"prev_value,omitempty"`
}

func (m *RemoveInput) Reset()         { *m = RemoveInput{} }
func (m *RemoveInput) String() string { return proto.CompactTextString(m) }
func (*RemoveInput) ProtoMessage()    {}
func (*RemoveInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{18}
}
func (m *RemoveInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveInput.Merge(m, src)
}
func (m *RemoveInput) XXX_Size() int {
	return m.Size()
}
func (m *RemoveInput) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveInput.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveInput proto.InternalMessageInfo

func (m *RemoveInput) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *RemoveInput) GetPrevValue() int64 {
	if m != nil {
		return m.PrevValue
	}
	return 0
}

type RemoveOutput struct {
	Value int64 `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *RemoveOutput) Reset()         { *m = RemoveOutput{} }
func (m *RemoveOutput) String() string { return proto.CompactTextString(m) }
func (*RemoveOutput) ProtoMessage()    {}
func (*RemoveOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{19}
}
func (m *RemoveOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveOutput.Merge(m, src)
}
func (m *RemoveOutput) XXX_Size() int {
	return m.Size()
}
func (m *RemoveOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveOutput.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveOutput proto.InternalMessageInfo

func (m *RemoveOutput) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type ClearInput struct {
}

func (m *ClearInput) Reset()         { *m = ClearInput{} }
func (m *ClearInput) String() string { return proto.CompactTextString(m) }
func (*ClearInput) ProtoMessage()    {}
func (*ClearInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{20}
}
func (m *ClearInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClearInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearInput.Merge(m, src)
}
func (m *ClearInput) XXX_Size() int {
	return m.Size()
}
func (m *ClearInput) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearInput.DiscardUnknown(m)
}

var xxx_messageInfo_ClearInput proto.InternalMessageInfo

type ClearOutput struct {
}

func (m *ClearOutput) Reset()         { *m = ClearOutput{} }
func (m *ClearOutput) String() string { return proto.CompactTextString(m) }
func (*ClearOutput) ProtoMessage()    {}
func (*ClearOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{21}
}
func (m *ClearOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClearOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearOutput.Merge(m, src)
}
func (m *ClearOutput) XXX_Size() int {
	return m.Size()
}
func (m *ClearOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearOutput.DiscardUnknown(m)
}

var xxx_messageInfo_ClearOutput proto.InternalMessageInfo

type LockInput struct {
	Keys    []string       `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
	Timeout *time.Duration `protobuf:"bytes,2,opt,name=timeout,proto3,stdduration" json:"timeout,omitempty"`
}

func (m *LockInput) Reset()         { *m = LockInput{} }
func (m *LockInput) String() string { return proto.CompactTextString(m) }
func (*LockInput) ProtoMessage()    {}
func (*LockInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{22}
}
func (m *LockInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LockInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockInput.Merge(m, src)
}
func (m *LockInput) XXX_Size() int {
	return m.Size()
}
func (m *LockInput) XXX_DiscardUnknown() {
	xxx_messageInfo_LockInput.DiscardUnknown(m)
}

var xxx_messageInfo_LockInput proto.InternalMessageInfo

func (m *LockInput) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *LockInput) GetTimeout() *time.Duration {
	if m != nil {
		return m.Timeout
	}
	return nil
}

type LockOutput struct {
}

func (m *LockOutput) Reset()         { *m = LockOutput{} }
func (m *LockOutput) String() string { return proto.CompactTextString(m) }
func (*LockOutput) ProtoMessage()    {}
func (*LockOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{23}
}
func (m *LockOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LockOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockOutput.Merge(m, src)
}
func (m *LockOutput) XXX_Size() int {
	return m.Size()
}
func (m *LockOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_LockOutput.DiscardUnknown(m)
}

var xxx_messageInfo_LockOutput proto.InternalMessageInfo

type UnlockInput struct {
	Keys []string `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
}

func (m *UnlockInput) Reset()         { *m = UnlockInput{} }
func (m *UnlockInput) String() string { return proto.CompactTextString(m) }
func (*UnlockInput) ProtoMessage()    {}
func (*UnlockInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{24}
}
func (m *UnlockInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnlockInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnlockInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnlockInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockInput.Merge(m, src)
}
func (m *UnlockInput) XXX_Size() int {
	return m.Size()
}
func (m *UnlockInput) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockInput.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockInput proto.InternalMessageInfo

func (m *UnlockInput) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

type UnlockOutput struct {
}

func (m *UnlockOutput) Reset()         { *m = UnlockOutput{} }
func (m *UnlockOutput) String() string { return proto.CompactTextString(m) }
func (*UnlockOutput) ProtoMessage()    {}
func (*UnlockOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{25}
}
func (m *UnlockOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnlockOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnlockOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnlockOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockOutput.Merge(m, src)
}
func (m *UnlockOutput) XXX_Size() int {
	return m.Size()
}
func (m *UnlockOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockOutput.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockOutput proto.InternalMessageInfo

type EntriesInput struct {
	Watch bool `protobuf:"varint,1,opt,name=watch,proto3" json:"watch,omitempty"`
}

func (m *EntriesInput) Reset()         { *m = EntriesInput{} }
func (m *EntriesInput) String() string { return proto.CompactTextString(m) }
func (*EntriesInput) ProtoMessage()    {}
func (*EntriesInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{26}
}
func (m *EntriesInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntriesInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntriesInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EntriesInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntriesInput.Merge(m, src)
}
func (m *EntriesInput) XXX_Size() int {
	return m.Size()
}
func (m *EntriesInput) XXX_DiscardUnknown() {
	xxx_messageInfo_EntriesInput.DiscardUnknown(m)
}

var xxx_messageInfo_EntriesInput proto.InternalMessageInfo

func (m *EntriesInput) GetWatch() bool {
	if m != nil {
		return m.Watch
	}
	return false
}

type EntriesOutput struct {
	Entry Entry `protobuf:"bytes,1,opt,name=entry,proto3" json:"entry"`
}

func (m *EntriesOutput) Reset()         { *m = EntriesOutput{} }
func (m *EntriesOutput) String() string { return proto.CompactTextString(m) }
func (*EntriesOutput) ProtoMessage()    {}
func (*EntriesOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{27}
}
func (m *EntriesOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntriesOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntriesOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EntriesOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntriesOutput.Merge(m, src)
}
func (m *EntriesOutput) XXX_Size() int {
	return m.Size()
}
func (m *EntriesOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_EntriesOutput.DiscardUnknown(m)
}

var xxx_messageInfo_EntriesOutput proto.InternalMessageInfo

func (m *EntriesOutput) GetEntry() Entry {
	if m != nil {
		return m.Entry
	}
	return Entry{}
}

type EventsInput struct {
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *EventsInput) Reset()         { *m = EventsInput{} }
func (m *EventsInput) String() string { return proto.CompactTextString(m) }
func (*EventsInput) ProtoMessage()    {}
func (*EventsInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{28}
}
func (m *EventsInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventsInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventsInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventsInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventsInput.Merge(m, src)
}
func (m *EventsInput) XXX_Size() int {
	return m.Size()
}
func (m *EventsInput) XXX_DiscardUnknown() {
	xxx_messageInfo_EventsInput.DiscardUnknown(m)
}

var xxx_messageInfo_EventsInput proto.InternalMessageInfo

func (m *EventsInput) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type EventsOutput struct {
	Event Event `protobuf:"bytes,1,opt,name=event,proto3" json:"event"`
}

func (m *EventsOutput) Reset()         { *m = EventsOutput{} }
func (m *EventsOutput) String() string { return proto.CompactTextString(m) }
func (*EventsOutput) ProtoMessage()    {}
func (*EventsOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{29}
}
func (m *EventsOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventsOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventsOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventsOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventsOutput.Merge(m, src)
}
func (m *EventsOutput) XXX_Size() int {
	return m.Size()
}
func (m *EventsOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_EventsOutput.DiscardUnknown(m)
}

var xxx_messageInfo_EventsOutput proto.InternalMessageInfo

func (m *EventsOutput) GetEvent() Event {
	if m != nil {
		return m.Event
	}
	return Event{}
}

type Event struct {
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Types that are valid to be assigned to Event:
	//	*Event_Inserted_
	//	*Event_Updated_
	//	*Event_Removed_
	Event isEvent_Event `protobuf_oneof:"event"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{30}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

type isEvent_Event interface {
	isEvent_Event()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Event_Inserted_ struct {
	Inserted *Event_Inserted `protobuf:"bytes,2,opt,name=inserted,proto3,oneof" json:"inserted,omitempty"`
}
type Event_Updated_ struct {
	Updated *Event_Updated `protobuf:"bytes,3,opt,name=updated,proto3,oneof" json:"updated,omitempty"`
}
type Event_Removed_ struct {
	Removed *Event_Removed `protobuf:"bytes,4,opt,name=removed,proto3,oneof" json:"removed,omitempty"`
}

func (*Event_Inserted_) isEvent_Event() {}
func (*Event_Updated_) isEvent_Event()  {}
func (*Event_Removed_) isEvent_Event()  {}

func (m *Event) GetEvent() isEvent_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *Event) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Event) GetInserted() *Event_Inserted {
	if x, ok := m.GetEvent().(*Event_Inserted_); ok {
		return x.Inserted
	}
	return nil
}

func (m *Event) GetUpdated() *Event_Updated {
	if x, ok := m.GetEvent().(*Event_Updated_); ok {
		return x.Updated
	}
	return nil
}

func (m *Event) GetRemoved() *Event_Removed {
	if x, ok := m.GetEvent().(*Event_Removed_); ok {
		return x.Removed
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Event) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Event_Inserted_)(nil),
		(*Event_Updated_)(nil),
		(*Event_Removed_)(nil),
	}
}

type Event_Inserted struct {
	Value int64 `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Event_Inserted) Reset()         { *m = Event_Inserted{} }
func (m *Event_Inserted) String() string { return proto.CompactTextString(m) }
func (*Event_Inserted) ProtoMessage()    {}
func (*Event_Inserted) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{30, 0}
}
func (m *Event_Inserted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event_Inserted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event_Inserted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event_Inserted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event_Inserted.Merge(m, src)
}
func (m *Event_Inserted) XXX_Size() int {
	return m.Size()
}
func (m *Event_Inserted) XXX_DiscardUnknown() {
	xxx_messageInfo_Event_Inserted.DiscardUnknown(m)
}

var xxx_messageInfo_Event_Inserted proto.InternalMessageInfo

func (m *Event_Inserted) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type Event_Updated struct {
	Value     int64 `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	PrevValue int64 `protobuf:"varint,2,opt,name=prev_value,json=prevValue,proto3" json:"prev_value,omitempty"`
}

func (m *Event_Updated) Reset()         { *m = Event_Updated{} }
func (m *Event_Updated) String() string { return proto.CompactTextString(m) }
func (*Event_Updated) ProtoMessage()    {}
func (*Event_Updated) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{30, 1}
}
func (m *Event_Updated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event_Updated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event_Updated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event_Updated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event_Updated.Merge(m, src)
}
func (m *Event_Updated) XXX_Size() int {
	return m.Size()
}
func (m *Event_Updated) XXX_DiscardUnknown() {
	xxx_messageInfo_Event_Updated.DiscardUnknown(m)
}

var xxx_messageInfo_Event_Updated proto.InternalMessageInfo

func (m *Event_Updated) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *Event_Updated) GetPrevValue() int64 {
	if m != nil {
		return m.PrevValue
	}
	return 0
}

type Event_Removed struct {
	Value int64 `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Event_Removed) Reset()         { *m = Event_Removed{} }
func (m *Event_Removed) String() string { return proto.CompactTextString(m) }
func (*Event_Removed) ProtoMessage()    {}
func (*Event_Removed) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{30, 2}
}
func (m *Event_Removed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event_Removed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event_Removed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event_Removed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event_Removed.Merge(m, src)
}
func (m *Event_Removed) XXX_Size() int {
	return m.Size()
}
func (m *Event_Removed) XXX_DiscardUnknown() {
	xxx_messageInfo_Event_Removed.DiscardUnknown(m)
}

var xxx_messageInfo_Event_Removed proto.InternalMessageInfo

func (m *Event_Removed) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type Entry struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value int64  `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Entry) Reset()         { *m = Entry{} }
func (m *Entry) String() string { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()    {}
func (*Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_94e5ac632a711c27, []int{31}
}
func (m *Entry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Entry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entry.Merge(m, src)
}
func (m *Entry) XXX_Size() int {
	return m.Size()
}
func (m *Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_Entry proto.InternalMessageInfo

func (m *Entry) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Entry) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func init() {
	proto.RegisterType((*AtomicCounterMapListener)(nil), "atomix.multiraft.atomic.countermap.v1.AtomicCounterMapListener")
	proto.RegisterType((*AtomicCounterMapEntry)(nil), "atomix.multiraft.atomic.countermap.v1.AtomicCounterMapEntry")
	proto.RegisterType((*AtomicCounterMapInput)(nil), "atomix.multiraft.atomic.countermap.v1.AtomicCounterMapInput")
	proto.RegisterType((*AtomicCounterMapOutput)(nil), "atomix.multiraft.atomic.countermap.v1.AtomicCounterMapOutput")
	proto.RegisterType((*SizeInput)(nil), "atomix.multiraft.atomic.countermap.v1.SizeInput")
	proto.RegisterType((*SizeOutput)(nil), "atomix.multiraft.atomic.countermap.v1.SizeOutput")
	proto.RegisterType((*SetInput)(nil), "atomix.multiraft.atomic.countermap.v1.SetInput")
	proto.RegisterType((*SetOutput)(nil), "atomix.multiraft.atomic.countermap.v1.SetOutput")
	proto.RegisterType((*InsertInput)(nil), "atomix.multiraft.atomic.countermap.v1.InsertInput")
	proto.RegisterType((*InsertOutput)(nil), "atomix.multiraft.atomic.countermap.v1.InsertOutput")
	proto.RegisterType((*UpdateInput)(nil), "atomix.multiraft.atomic.countermap.v1.UpdateInput")
	proto.RegisterType((*UpdateOutput)(nil), "atomix.multiraft.atomic.countermap.v1.UpdateOutput")
	proto.RegisterType((*IncrementInput)(nil), "atomix.multiraft.atomic.countermap.v1.IncrementInput")
	proto.RegisterType((*IncrementOutput)(nil), "atomix.multiraft.atomic.countermap.v1.IncrementOutput")
	proto.RegisterType((*DecrementInput)(nil), "atomix.multiraft.atomic.countermap.v1.DecrementInput")
	proto.RegisterType((*DecrementOutput)(nil), "atomix.multiraft.atomic.countermap.v1.DecrementOutput")
	proto.RegisterType((*GetInput)(nil), "atomix.multiraft.atomic.countermap.v1.GetInput")
	proto.RegisterType((*GetOutput)(nil), "atomix.multiraft.atomic.countermap.v1.GetOutput")
	proto.RegisterType((*RemoveInput)(nil), "atomix.multiraft.atomic.countermap.v1.RemoveInput")
	proto.RegisterType((*RemoveOutput)(nil), "atomix.multiraft.atomic.countermap.v1.RemoveOutput")
	proto.RegisterType((*ClearInput)(nil), "atomix.multiraft.atomic.countermap.v1.ClearInput")
	proto.RegisterType((*ClearOutput)(nil), "atomix.multiraft.atomic.countermap.v1.ClearOutput")
	proto.RegisterType((*LockInput)(nil), "atomix.multiraft.atomic.countermap.v1.LockInput")
	proto.RegisterType((*LockOutput)(nil), "atomix.multiraft.atomic.countermap.v1.LockOutput")
	proto.RegisterType((*UnlockInput)(nil), "atomix.multiraft.atomic.countermap.v1.UnlockInput")
	proto.RegisterType((*UnlockOutput)(nil), "atomix.multiraft.atomic.countermap.v1.UnlockOutput")
	proto.RegisterType((*EntriesInput)(nil), "atomix.multiraft.atomic.countermap.v1.EntriesInput")
	proto.RegisterType((*EntriesOutput)(nil), "atomix.multiraft.atomic.countermap.v1.EntriesOutput")
	proto.RegisterType((*EventsInput)(nil), "atomix.multiraft.atomic.countermap.v1.EventsInput")
	proto.RegisterType((*EventsOutput)(nil), "atomix.multiraft.atomic.countermap.v1.EventsOutput")
	proto.RegisterType((*Event)(nil), "atomix.multiraft.atomic.countermap.v1.Event")
	proto.RegisterType((*Event_Inserted)(nil), "atomix.multiraft.atomic.countermap.v1.Event.Inserted")
	proto.RegisterType((*Event_Updated)(nil), "atomix.multiraft.atomic.countermap.v1.Event.Updated")
	proto.RegisterType((*Event_Removed)(nil), "atomix.multiraft.atomic.countermap.v1.Event.Removed")
	proto.RegisterType((*Entry)(nil), "atomix.multiraft.atomic.countermap.v1.Entry")
}

func init() {
	proto.RegisterFile("atomix/multiraft/atomic/countermap/v1/fsm.proto", fileDescriptor_94e5ac632a711c27)
}

var fileDescriptor_94e5ac632a711c27 = []byte{
	// 1087 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x97, 0xc1, 0x6f, 0xe3, 0xc4,
	0x17, 0xc7, 0xe3, 0x4d, 0xd2, 0xc4, 0xcf, 0xe9, 0xfe, 0x7e, 0xb2, 0x16, 0x64, 0x22, 0x48, 0xb2,
	0x16, 0x48, 0x15, 0xa2, 0x76, 0x93, 0x6c, 0x57, 0x70, 0x59, 0x44, 0xda, 0x6e, 0x5b, 0xd4, 0x68,
	0x91, 0xcb, 0x56, 0x80, 0x90, 0x90, 0x1b, 0x4f, 0xb3, 0x56, 0x13, 0x3b, 0x72, 0xc6, 0x61, 0xb3,
	0x7f, 0x02, 0x27, 0x8e, 0x9c, 0xf8, 0x6f, 0x90, 0xf6, 0xb8, 0x12, 0x17, 0x4e, 0x0b, 0x6a, 0xff,
	0x0b, 0x4e, 0x68, 0x66, 0xec, 0xf1, 0xc4, 0xc9, 0xaa, 0x9e, 0x5b, 0xc6, 0x9a, 0xf7, 0x79, 0x6f,
	0x66, 0xde, 0xf7, 0xbd, 0x17, 0xb0, 0x5d, 0x1c, 0x4e, 0xfd, 0x97, 0xf6, 0x34, 0x9e, 0x60, 0x3f,
	0x72, 0xaf, 0x30, 0xfb, 0x30, 0xb2, 0x47, 0x61, 0x1c, 0x60, 0x14, 0x4d, 0xdd, 0x99, 0xbd, 0xe8,
	0xda, 0x57, 0xf3, 0xa9, 0x35, 0x8b, 0x42, 0x1c, 0xea, 0x9f, 0x30, 0x03, 0x8b, 0x1b, 0x58, 0xcc,
	0xc0, 0xca, 0x0c, 0xac, 0x45, 0xb7, 0xd9, 0x1a, 0x87, 0xe1, 0x78, 0x82, 0x6c, 0x6a, 0x74, 0x19,
	0x5f, 0xd9, 0x5e, 0x1c, 0xb9, 0xd8, 0x0f, 0x03, 0x86, 0x69, 0x3e, 0x18, 0x87, 0xe3, 0x90, 0xfe,
	0xb4, 0xc9, 0x2f, 0xf6, 0xd5, 0xfc, 0x45, 0x01, 0xe3, 0x2b, 0x8a, 0x3b, 0x60, 0xb4, 0xa1, 0x3b,
	0x3b, 0xf3, 0xe7, 0x18, 0x05, 0x28, 0xd2, 0x7f, 0x84, 0xaa, 0x1f, 0x78, 0xe8, 0xa5, 0xa1, 0x74,
	0x94, 0x9d, 0xca, 0xe0, 0xe9, 0xbf, 0x6f, 0xdb, 0x83, 0xb1, 0x8f, 0x5f, 0xc4, 0x97, 0xd6, 0x28,
	0x9c, 0xae, 0x1c, 0x64, 0x97, 0x04, 0xb6, 0x3b, 0xc7, 0x61, 0xe4, 0x8e, 0x91, 0xed, 0xce, 0xfc,
	0xf5, 0x63, 0x2e, 0xba, 0xd6, 0x29, 0xa1, 0x39, 0x0c, 0xaa, 0xff, 0x1f, 0xca, 0xd7, 0x68, 0x69,
	0xdc, 0xeb, 0x28, 0x3b, 0xaa, 0x43, 0x7e, 0x9a, 0x5f, 0xc2, 0x7b, 0xf9, 0x58, 0x8e, 0x02, 0x1c,
	0x2d, 0xd3, 0xad, 0x0a, 0xdf, 0xaa, 0x3f, 0x80, 0xea, 0xc2, 0x9d, 0xc4, 0x88, 0x9a, 0x97, 0x1d,
	0xb6, 0x30, 0xff, 0xa8, 0xad, 0x13, 0x4e, 0x83, 0x59, 0x8c, 0xf5, 0xa7, 0x50, 0x99, 0xfb, 0xaf,
	0x10, 0x45, 0x68, 0xbd, 0x3d, 0xab, 0xd0, 0x9d, 0x5a, 0xe7, 0xfe, 0x2b, 0x44, 0xed, 0x4f, 0x4a,
	0x0e, 0xb5, 0xd7, 0xcf, 0x60, 0xcb, 0x0f, 0xe6, 0x28, 0xc2, 0x46, 0x99, 0x92, 0x7a, 0x05, 0x49,
	0xa7, 0xd4, 0x28, 0x65, 0x25, 0x0c, 0x42, 0x8b, 0x67, 0x9e, 0x8b, 0x91, 0x51, 0x91, 0xa2, 0x3d,
	0xa7, 0x46, 0x9c, 0xc6, 0x18, 0xfa, 0x73, 0x50, 0xfd, 0x60, 0x14, 0xa1, 0x29, 0x0a, 0xb0, 0x51,
	0xa5, 0xc0, 0xfd, 0xc2, 0xe1, 0x25, 0x76, 0x29, 0x33, 0x23, 0x11, 0xac, 0x87, 0x52, 0xec, 0x96,
	0x14, 0xf6, 0x10, 0xe5, 0xb1, 0x9c, 0xa4, 0x1f, 0x40, 0x79, 0x8c, 0xb0, 0x51, 0xa3, 0x40, 0xbb,
	0x20, 0xf0, 0x18, 0x71, 0x14, 0xb1, 0x26, 0x17, 0x18, 0xa1, 0x69, 0xb8, 0x40, 0x46, 0x5d, 0xea,
	0x02, 0x1d, 0x6a, 0xc4, 0x2f, 0x90, 0x31, 0xf4, 0x53, 0xa8, 0x8e, 0x26, 0xc8, 0x8d, 0x0c, 0x95,
	0xc2, 0xba, 0x05, 0x61, 0x07, 0xc4, 0x26, 0x65, 0x31, 0x02, 0xc9, 0xb7, 0x49, 0x38, 0xba, 0x36,
	0x40, 0x2a, 0xdf, 0xce, 0xc2, 0xd1, 0x35, 0xcf, 0x37, 0x62, 0x4f, 0x33, 0x24, 0xa0, 0x24, 0x4d,
	0x2e, 0x43, 0xa8, 0x51, 0x96, 0x21, 0x74, 0xa9, 0x3f, 0x83, 0x1a, 0x0a, 0x70, 0xe4, 0xa3, 0xb9,
	0xd1, 0xa0, 0xb8, 0x7e, 0x41, 0xdc, 0x11, 0xb3, 0x4a, 0x79, 0x29, 0x85, 0x84, 0x87, 0x16, 0x28,
	0xc0, 0x73, 0x63, 0x5b, 0x2a, 0xbc, 0x23, 0x6a, 0xc4, 0xc3, 0x63, 0x8c, 0x41, 0x8d, 0xd4, 0x9b,
	0x59, 0x8c, 0xcd, 0x3f, 0x6b, 0xf0, 0x7e, 0x5e, 0xc7, 0xcf, 0x62, 0x4c, 0x84, 0x7c, 0xbc, 0x22,
	0xe4, 0xae, 0x84, 0x90, 0x19, 0x80, 0x2b, 0x79, 0x98, 0x53, 0x72, 0x5f, 0x4a, 0xc9, 0x1c, 0x96,
	0x4a, 0x79, 0x98, 0x93, 0x72, 0x5f, 0x4a, 0xca, 0x19, 0x2e, 0xd1, 0xf2, 0xc5, 0xba, 0x96, 0x1f,
	0xcb, 0x6a, 0x99, 0x43, 0x05, 0x31, 0x5f, 0xac, 0x8b, 0xf9, 0xb1, 0xac, 0x98, 0x33, 0x6e, 0xa6,
	0xe6, 0x43, 0x51, 0xcd, 0x7b, 0xc5, 0xd5, 0xcc, 0x59, 0x54, 0xce, 0xc3, 0x9c, 0x9c, 0xfb, 0x52,
	0x72, 0xce, 0x2e, 0x31, 0xd1, 0xf3, 0xd7, 0xab, 0x7a, 0xee, 0xc9, 0xe8, 0x99, 0xc3, 0x12, 0x41,
	0x1f, 0xaf, 0x08, 0xba, 0x2b, 0x21, 0xe8, 0x2c, 0xef, 0xa8, 0x06, 0x87, 0x39, 0x45, 0xf7, 0xa5,
	0x14, 0x2d, 0x24, 0x0a, 0x93, 0xf4, 0x37, 0x79, 0x49, 0x3f, 0x92, 0x93, 0x34, 0x07, 0x72, 0x4d,
	0x0f, 0x73, 0x9a, 0xee, 0x4b, 0x69, 0x3a, 0x0b, 0x30, 0x11, 0x75, 0x1d, 0xb6, 0x42, 0xfa, 0xcd,
	0xd4, 0x40, 0xe5, 0x0d, 0xd5, 0xec, 0x00, 0x64, 0xa2, 0xd4, 0x75, 0x41, 0xd5, 0xdb, 0x4c, 0xa0,
	0x66, 0x0f, 0xea, 0xe7, 0x49, 0xb9, 0x2f, 0x3c, 0x00, 0x7c, 0x0a, 0xea, 0x79, 0x9a, 0x54, 0xfa,
	0x47, 0x00, 0xb3, 0x08, 0x2d, 0x7e, 0x62, 0xfb, 0x14, 0xba, 0x4f, 0x25, 0x5f, 0x2e, 0xe8, 0xde,
	0x7d, 0xd0, 0x84, 0xae, 0x5c, 0xd8, 0xc5, 0x7d, 0x68, 0x88, 0x25, 0xc0, 0xfc, 0x16, 0x34, 0xa1,
	0x1d, 0x17, 0xc5, 0xe4, 0x82, 0x2b, 0xe7, 0x83, 0xdb, 0x85, 0x86, 0x58, 0x19, 0xee, 0x3a, 0xcb,
	0xe7, 0x70, 0x7f, 0xb5, 0x85, 0x6f, 0x8e, 0xc3, 0x43, 0x13, 0xec, 0xa6, 0x71, 0xd0, 0x85, 0xb9,
	0x07, 0xff, 0xcb, 0x15, 0x8c, 0x02, 0xbe, 0x56, 0xfb, 0xba, 0x8c, 0xaf, 0x5c, 0x11, 0xb9, 0xcb,
	0xd7, 0x87, 0x50, 0x3f, 0x7e, 0x67, 0x0e, 0x98, 0x0f, 0x41, 0xe5, 0x25, 0x24, 0xbb, 0x66, 0x45,
	0x7c, 0xad, 0x27, 0xa0, 0x09, 0xbd, 0x7e, 0x7d, 0xe6, 0xbc, 0xeb, 0x1d, 0x3e, 0x86, 0x86, 0x58,
	0x5c, 0xde, 0xe1, 0xa5, 0x01, 0x90, 0x0d, 0x01, 0xe6, 0x36, 0x68, 0x42, 0x09, 0x31, 0x7f, 0x00,
	0x95, 0xf7, 0x75, 0x92, 0xe8, 0xd7, 0x68, 0x39, 0x37, 0x94, 0x4e, 0x79, 0x47, 0x75, 0xe8, 0x6f,
	0xfd, 0x0b, 0xa8, 0x61, 0x7f, 0x8a, 0xc2, 0x18, 0xd3, 0xc0, 0xb4, 0xde, 0x07, 0x16, 0x9b, 0xe5,
	0xad, 0x74, 0x96, 0xb7, 0x0e, 0x93, 0x59, 0x7e, 0x50, 0xf9, 0xed, 0xef, 0xb6, 0xe2, 0xa4, 0xfb,
	0x89, 0xe3, 0xac, 0xc4, 0x98, 0x0f, 0x41, 0x13, 0xfa, 0xfe, 0x26, 0x5f, 0x24, 0x7b, 0xc5, 0x42,
	0x42, 0xce, 0x27, 0xf6, 0x76, 0x72, 0xbe, 0x9f, 0x5d, 0x3c, 0x7a, 0x41, 0xcf, 0x57, 0x77, 0xd8,
	0xc2, 0xfc, 0x1e, 0xb6, 0x57, 0xca, 0x85, 0x7e, 0x02, 0x55, 0x52, 0x2e, 0x96, 0x49, 0x1b, 0xfe,
	0x4c, 0xa2, 0xe6, 0x2c, 0x07, 0x95, 0xd7, 0x6f, 0xdb, 0x25, 0x87, 0x01, 0xcc, 0x36, 0x68, 0xc2,
	0x30, 0xb0, 0xe1, 0x91, 0xbf, 0x83, 0x86, 0x58, 0x59, 0xa8, 0x6b, 0xb2, 0x96, 0x75, 0x4d, 0x6c,
	0xb8, 0x6b, 0xb2, 0x30, 0x7f, 0x2f, 0x43, 0x95, 0x7e, 0xde, 0x90, 0xc0, 0xe7, 0x50, 0x67, 0x8d,
	0x1d, 0x79, 0xc9, 0xa3, 0xec, 0xcb, 0x38, 0x4a, 0xa6, 0x04, 0xe4, 0x9d, 0x94, 0x1c, 0x0e, 0x22,
	0xb5, 0x9a, 0xb5, 0x77, 0x2f, 0x99, 0x39, 0x1e, 0x49, 0x31, 0x59, 0x41, 0x20, 0xc8, 0x14, 0x43,
	0x88, 0xac, 0xd7, 0x79, 0xc9, 0xd8, 0x21, 0x47, 0x64, 0xa9, 0x4d, 0x89, 0x09, 0xa6, 0xd9, 0x81,
	0x7a, 0x1a, 0xfb, 0xe6, 0x64, 0x6f, 0x3e, 0x81, 0x5a, 0x12, 0xc9, 0xe6, 0x0d, 0x39, 0x49, 0xdd,
	0xcb, 0x49, 0xaa, 0xd9, 0x86, 0x5a, 0xe2, 0x77, 0xb3, 0x3d, 0x19, 0x03, 0xd9, 0x03, 0xd9, 0x50,
	0x95, 0xfa, 0xff, 0x37, 0x30, 0x5e, 0xdf, 0xb4, 0x94, 0x37, 0x37, 0x2d, 0xe5, 0x9f, 0x9b, 0x96,
	0xf2, 0xeb, 0x6d, 0xab, 0xf4, 0xe6, 0xb6, 0x55, 0xfa, 0xeb, 0xb6, 0x55, 0xba, 0xdc, 0xa2, 0x52,
	0xea, 0xff, 0x17, 0x00, 0x00, 0xff, 0xff, 0x56, 0x3f, 0x76, 0xd0, 0x7e, 0x0f, 0x00, 0x00,
}

func (m *AtomicCounterMapListener) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AtomicCounterMapListener) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapListener) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.Index != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AtomicCounterMapEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AtomicCounterMapEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AtomicCounterMapInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AtomicCounterMapInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Input != nil {
		{
			size := m.Input.Size()
			i -= size
			if _, err := m.Input.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AtomicCounterMapInput_Size_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapInput_Size_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Size_ != nil {
		{
			size, err := m.Size_.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AtomicCounterMapInput_Insert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapInput_Insert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Insert != nil {
		{
			size, err := m.Insert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AtomicCounterMapInput_Update) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapInput_Update) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Update != nil {
		{
			size, err := m.Update.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AtomicCounterMapInput_Increment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapInput_Increment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Increment != nil {
		{
			size, err := m.Increment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *AtomicCounterMapInput_Decrement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapInput_Decrement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Decrement != nil {
		{
			size, err := m.Decrement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *AtomicCounterMapInput_Get) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapInput_Get) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Get != nil {
		{
			size, err := m.Get.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *AtomicCounterMapInput_Remove) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapInput_Remove) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Remove != nil {
		{
			size, err := m.Remove.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *AtomicCounterMapInput_Clear) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapInput_Clear) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Clear != nil {
		{
			size, err := m.Clear.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *AtomicCounterMapInput_Lock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapInput_Lock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Lock != nil {
		{
			size, err := m.Lock.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *AtomicCounterMapInput_Unlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapInput_Unlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Unlock != nil {
		{
			size, err := m.Unlock.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *AtomicCounterMapInput_Entries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapInput_Entries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Entries != nil {
		{
			size, err := m.Entries.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *AtomicCounterMapInput_Events) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapInput_Events) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Events != nil {
		{
			size, err := m.Events.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *AtomicCounterMapOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AtomicCounterMapOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Output != nil {
		{
			size := m.Output.Size()
			i -= size
			if _, err := m.Output.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AtomicCounterMapOutput_Size_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapOutput_Size_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Size_ != nil {
		{
			size, err := m.Size_.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AtomicCounterMapOutput_Insert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapOutput_Insert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Insert != nil {
		{
			size, err := m.Insert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AtomicCounterMapOutput_Update) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapOutput_Update) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Update != nil {
		{
			size, err := m.Update.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AtomicCounterMapOutput_Increment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapOutput_Increment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Increment != nil {
		{
			size, err := m.Increment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *AtomicCounterMapOutput_Decrement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapOutput_Decrement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Decrement != nil {
		{
			size, err := m.Decrement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *AtomicCounterMapOutput_Get) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapOutput_Get) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Get != nil {
		{
			size, err := m.Get.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *AtomicCounterMapOutput_Remove) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapOutput_Remove) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Remove != nil {
		{
			size, err := m.Remove.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *AtomicCounterMapOutput_Clear) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapOutput_Clear) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Clear != nil {
		{
			size, err := m.Clear.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *AtomicCounterMapOutput_Lock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapOutput_Lock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Lock != nil {
		{
			size, err := m.Lock.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *AtomicCounterMapOutput_Unlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapOutput_Unlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Unlock != nil {
		{
			size, err := m.Unlock.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *AtomicCounterMapOutput_Entries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapOutput_Entries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Entries != nil {
		{
			size, err := m.Entries.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *AtomicCounterMapOutput_Events) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicCounterMapOutput_Events) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Events != nil {
		{
			size, err := m.Events.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *SizeInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SizeInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SizeInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SizeOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SizeOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SizeOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Size_ != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrevValue != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.PrevValue))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InsertInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsertInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InsertInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InsertOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsertOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InsertOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *UpdateInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrevValue != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.PrevValue))
		i--
		dAtA[i] = 0x18
	}
	if m.Value != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrevValue != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.PrevValue))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IncrementInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncrementInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IncrementInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Delta != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Delta))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IncrementOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncrementOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IncrementOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrevValue != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.PrevValue))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DecrementInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecrementInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecrementInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Delta != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Delta))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DecrementOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecrementOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecrementOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrevValue != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.PrevValue))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoveInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrevValue != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.PrevValue))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *RemoveOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClearInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ClearOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *LockInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timeout != nil {
		n25, err25 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.Timeout, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Timeout):])
		if err25 != nil {
			return 0, err25
		}
		i -= n25
		i = encodeVarintFsm(dAtA, i, uint64(n25))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintFsm(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LockOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *UnlockInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnlockInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintFsm(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UnlockOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnlockOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *EntriesInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntriesInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntriesInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Watch {
		i--
		if m.Watch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EntriesOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntriesOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntriesOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Entry.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFsm(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventsInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventsInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventsInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventsOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventsOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventsOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Event.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFsm(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Event != nil {
		{
			size := m.Event.Size()
			i -= size
			if _, err := m.Event.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Event_Inserted_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_Inserted_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Inserted != nil {
		{
			size, err := m.Inserted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Event_Updated_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_Updated_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Updated != nil {
		{
			size, err := m.Updated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Event_Removed_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_Removed_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Removed != nil {
		{
			size, err := m.Removed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Event_Inserted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event_Inserted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_Inserted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Event_Updated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event_Updated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_Updated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrevValue != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.PrevValue))
		i--
		dAtA[i] = 0x10
	}
	if m.Value != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Event_Removed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event_Removed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_Removed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintFsm(dAtA []byte, offset int, v uint64) int {
	offset -= sovFsm(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AtomicCounterMapListener) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovFsm(uint64(m.Index))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}

func (m *AtomicCounterMapEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovFsm(uint64(m.Value))
	}
	return n
}

func (m *AtomicCounterMapInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Input != nil {
		n += m.Input.Size()
	}
	return n
}

func (m *AtomicCounterMapInput_Size_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Size_ != nil {
		l = m.Size_.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicCounterMapInput_Insert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Insert != nil {
		l = m.Insert.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicCounterMapInput_Update) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Update != nil {
		l = m.Update.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicCounterMapInput_Increment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Increment != nil {
		l = m.Increment.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicCounterMapInput_Decrement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Decrement != nil {
		l = m.Decrement.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicCounterMapInput_Get) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Get != nil {
		l = m.Get.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicCounterMapInput_Remove) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Remove != nil {
		l = m.Remove.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicCounterMapInput_Clear) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Clear != nil {
		l = m.Clear.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicCounterMapInput_Lock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lock != nil {
		l = m.Lock.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicCounterMapInput_Unlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Unlock != nil {
		l = m.Unlock.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicCounterMapInput_Entries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Entries != nil {
		l = m.Entries.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicCounterMapInput_Events) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Events != nil {
		l = m.Events.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicCounterMapOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		n += m.Output.Size()
	}
	return n
}

func (m *AtomicCounterMapOutput_Size_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Size_ != nil {
		l = m.Size_.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicCounterMapOutput_Insert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Insert != nil {
		l = m.Insert.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicCounterMapOutput_Update) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Update != nil {
		l = m.Update.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicCounterMapOutput_Increment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Increment != nil {
		l = m.Increment.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicCounterMapOutput_Decrement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Decrement != nil {
		l = m.Decrement.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicCounterMapOutput_Get) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Get != nil {
		l = m.Get.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicCounterMapOutput_Remove) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Remove != nil {
		l = m.Remove.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicCounterMapOutput_Clear) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Clear != nil {
		l = m.Clear.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicCounterMapOutput_Lock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lock != nil {
		l = m.Lock.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicCounterMapOutput_Unlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Unlock != nil {
		l = m.Unlock.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicCounterMapOutput_Entries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Entries != nil {
		l = m.Entries.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicCounterMapOutput_Events) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Events != nil {
		l = m.Events.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *SizeInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SizeOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Size_ != 0 {
		n += 1 + sovFsm(uint64(m.Size_))
	}
	return n
}

func (m *SetInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovFsm(uint64(m.Value))
	}
	return n
}

func (m *SetOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrevValue != 0 {
		n += 1 + sovFsm(uint64(m.PrevValue))
	}
	return n
}

func (m *InsertInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovFsm(uint64(m.Value))
	}
	return n
}

func (m *InsertOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *UpdateInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovFsm(uint64(m.Value))
	}
	if m.PrevValue != 0 {
		n += 1 + sovFsm(uint64(m.PrevValue))
	}
	return n
}

func (m *UpdateOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrevValue != 0 {
		n += 1 + sovFsm(uint64(m.PrevValue))
	}
	return n
}

func (m *IncrementInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	if m.Delta != 0 {
		n += 1 + sovFsm(uint64(m.Delta))
	}
	return n
}

func (m *IncrementOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrevValue != 0 {
		n += 1 + sovFsm(uint64(m.PrevValue))
	}
	return n
}

func (m *DecrementInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	if m.Delta != 0 {
		n += 1 + sovFsm(uint64(m.Delta))
	}
	return n
}

func (m *DecrementOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrevValue != 0 {
		n += 1 + sovFsm(uint64(m.PrevValue))
	}
	return n
}

func (m *GetInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}

func (m *GetOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 1 + sovFsm(uint64(m.Value))
	}
	return n
}

func (m *RemoveInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	if m.PrevValue != 0 {
		n += 1 + sovFsm(uint64(m.PrevValue))
	}
	return n
}

func (m *RemoveOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 1 + sovFsm(uint64(m.Value))
	}
	return n
}

func (m *ClearInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ClearOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *LockInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovFsm(uint64(l))
		}
	}
	if m.Timeout != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Timeout)
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}

func (m *LockOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *UnlockInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovFsm(uint64(l))
		}
	}
	return n
}

func (m *UnlockOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *EntriesInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Watch {
		n += 2
	}
	return n
}

func (m *EntriesOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Entry.Size()
	n += 1 + l + sovFsm(uint64(l))
	return n
}

func (m *EventsInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}

func (m *EventsOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Event.Size()
	n += 1 + l + sovFsm(uint64(l))
	return n
}

func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	if m.Event != nil {
		n += m.Event.Size()
	}
	return n
}

func (m *Event_Inserted_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Inserted != nil {
		l = m.Inserted.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *Event_Updated_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Updated != nil {
		l = m.Updated.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *Event_Removed_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Removed != nil {
		l = m.Removed.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *Event_Inserted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 1 + sovFsm(uint64(m.Value))
	}
	return n
}

func (m *Event_Updated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 1 + sovFsm(uint64(m.Value))
	}
	if m.PrevValue != 0 {
		n += 1 + sovFsm(uint64(m.PrevValue))
	}
	return n
}

func (m *Event_Removed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 1 + sovFsm(uint64(m.Value))
	}
	return n
}

func (m *Entry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovFsm(uint64(m.Value))
	}
	return n
}

func sovFsm(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFsm(x uint64) (n int) {
	return sovFsm(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AtomicCounterMapListener) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AtomicCounterMapListener: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AtomicCounterMapListener: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AtomicCounterMapEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AtomicCounterMapEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AtomicCounterMapEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AtomicCounterMapInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AtomicCounterMapInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AtomicCounterMapInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SizeInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &AtomicCounterMapInput_Size_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Insert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InsertInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &AtomicCounterMapInput_Insert{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UpdateInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &AtomicCounterMapInput_Update{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Increment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IncrementInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &AtomicCounterMapInput_Increment{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decrement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DecrementInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &AtomicCounterMapInput_Decrement{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Get", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &AtomicCounterMapInput_Get{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RemoveInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &AtomicCounterMapInput_Remove{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clear", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClearInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &AtomicCounterMapInput_Clear{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LockInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &AtomicCounterMapInput_Lock{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UnlockInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &AtomicCounterMapInput_Unlock{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EntriesInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &AtomicCounterMapInput_Entries{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EventsInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &AtomicCounterMapInput_Events{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AtomicCounterMapOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AtomicCounterMapOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AtomicCounterMapOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SizeOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &AtomicCounterMapOutput_Size_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Insert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InsertOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &AtomicCounterMapOutput_Insert{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UpdateOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &AtomicCounterMapOutput_Update{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Increment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IncrementOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &AtomicCounterMapOutput_Increment{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decrement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DecrementOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &AtomicCounterMapOutput_Decrement{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Get", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &AtomicCounterMapOutput_Get{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RemoveOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &AtomicCounterMapOutput_Remove{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clear", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClearOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &AtomicCounterMapOutput_Clear{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LockOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &AtomicCounterMapOutput_Lock{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UnlockOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &AtomicCounterMapOutput_Unlock{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EntriesOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &AtomicCounterMapOutput_Entries{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EventsOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &AtomicCounterMapOutput_Events{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SizeInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SizeInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SizeInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SizeOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SizeOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SizeOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevValue", wireType)
			}
			m.PrevValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsertInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsertOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevValue", wireType)
			}
			m.PrevValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevValue", wireType)
			}
			m.PrevValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncrementInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncrementInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncrementInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta", wireType)
			}
			m.Delta = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delta |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncrementOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncrementOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncrementOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevValue", wireType)
			}
			m.PrevValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecrementInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecrementInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecrementInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta", wireType)
			}
			m.Delta = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delta |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecrementOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecrementOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecrementOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevValue", wireType)
			}
			m.PrevValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevValue", wireType)
			}
			m.PrevValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timeout == nil {
				m.Timeout = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.Timeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntriesInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntriesInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntriesInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Watch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Watch = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntriesOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntriesOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntriesOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Entry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventsInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventsInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventsInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventsOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventsOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventsOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inserted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Event_Inserted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &Event_Inserted_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Event_Updated{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &Event_Updated_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Removed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Event_Removed{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &Event_Removed_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event_Inserted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Inserted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Inserted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event_Updated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Updated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Updated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevValue", wireType)
			}
			m.PrevValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event_Removed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Removed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Removed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFsm(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFsm
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFsm
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFsm
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFsm        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFsm          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFsm = fmt.Errorf("proto: unexpected end of group")
)
