// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: atomix/multiraft/atomic/value/v1/fsm.proto

package v1

import (
	fmt "fmt"
	github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1 "github.com/atomix/multi-raft-storage/api/atomix/multiraft/v1"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AtomicValueState struct {
	Value  *Value     `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Expire *time.Time `protobuf:"bytes,2,opt,name=expire,proto3,stdtime" json:"expire,omitempty"`
}

func (m *AtomicValueState) Reset()         { *m = AtomicValueState{} }
func (m *AtomicValueState) String() string { return proto.CompactTextString(m) }
func (*AtomicValueState) ProtoMessage()    {}
func (*AtomicValueState) Descriptor() ([]byte, []int) {
	return fileDescriptor_773e0cea356866c7, []int{0}
}
func (m *AtomicValueState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AtomicValueState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AtomicValueState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AtomicValueState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AtomicValueState.Merge(m, src)
}
func (m *AtomicValueState) XXX_Size() int {
	return m.Size()
}
func (m *AtomicValueState) XXX_DiscardUnknown() {
	xxx_messageInfo_AtomicValueState.DiscardUnknown(m)
}

var xxx_messageInfo_AtomicValueState proto.InternalMessageInfo

func (m *AtomicValueState) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *AtomicValueState) GetExpire() *time.Time {
	if m != nil {
		return m.Expire
	}
	return nil
}

type AtomicValueInput struct {
	// Types that are valid to be assigned to Input:
	//	*AtomicValueInput_Get
	//	*AtomicValueInput_Set
	//	*AtomicValueInput_Update
	//	*AtomicValueInput_Delete
	//	*AtomicValueInput_Watch
	//	*AtomicValueInput_Events
	Input isAtomicValueInput_Input `protobuf_oneof:"input"`
}

func (m *AtomicValueInput) Reset()         { *m = AtomicValueInput{} }
func (m *AtomicValueInput) String() string { return proto.CompactTextString(m) }
func (*AtomicValueInput) ProtoMessage()    {}
func (*AtomicValueInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_773e0cea356866c7, []int{1}
}
func (m *AtomicValueInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AtomicValueInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AtomicValueInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AtomicValueInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AtomicValueInput.Merge(m, src)
}
func (m *AtomicValueInput) XXX_Size() int {
	return m.Size()
}
func (m *AtomicValueInput) XXX_DiscardUnknown() {
	xxx_messageInfo_AtomicValueInput.DiscardUnknown(m)
}

var xxx_messageInfo_AtomicValueInput proto.InternalMessageInfo

type isAtomicValueInput_Input interface {
	isAtomicValueInput_Input()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AtomicValueInput_Get struct {
	Get *GetInput `protobuf:"bytes,1,opt,name=get,proto3,oneof" json:"get,omitempty"`
}
type AtomicValueInput_Set struct {
	Set *SetInput `protobuf:"bytes,2,opt,name=set,proto3,oneof" json:"set,omitempty"`
}
type AtomicValueInput_Update struct {
	Update *UpdateInput `protobuf:"bytes,3,opt,name=update,proto3,oneof" json:"update,omitempty"`
}
type AtomicValueInput_Delete struct {
	Delete *DeleteInput `protobuf:"bytes,4,opt,name=delete,proto3,oneof" json:"delete,omitempty"`
}
type AtomicValueInput_Watch struct {
	Watch *WatchInput `protobuf:"bytes,5,opt,name=watch,proto3,oneof" json:"watch,omitempty"`
}
type AtomicValueInput_Events struct {
	Events *EventsInput `protobuf:"bytes,6,opt,name=events,proto3,oneof" json:"events,omitempty"`
}

func (*AtomicValueInput_Get) isAtomicValueInput_Input()    {}
func (*AtomicValueInput_Set) isAtomicValueInput_Input()    {}
func (*AtomicValueInput_Update) isAtomicValueInput_Input() {}
func (*AtomicValueInput_Delete) isAtomicValueInput_Input() {}
func (*AtomicValueInput_Watch) isAtomicValueInput_Input()  {}
func (*AtomicValueInput_Events) isAtomicValueInput_Input() {}

func (m *AtomicValueInput) GetInput() isAtomicValueInput_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *AtomicValueInput) GetGet() *GetInput {
	if x, ok := m.GetInput().(*AtomicValueInput_Get); ok {
		return x.Get
	}
	return nil
}

func (m *AtomicValueInput) GetSet() *SetInput {
	if x, ok := m.GetInput().(*AtomicValueInput_Set); ok {
		return x.Set
	}
	return nil
}

func (m *AtomicValueInput) GetUpdate() *UpdateInput {
	if x, ok := m.GetInput().(*AtomicValueInput_Update); ok {
		return x.Update
	}
	return nil
}

func (m *AtomicValueInput) GetDelete() *DeleteInput {
	if x, ok := m.GetInput().(*AtomicValueInput_Delete); ok {
		return x.Delete
	}
	return nil
}

func (m *AtomicValueInput) GetWatch() *WatchInput {
	if x, ok := m.GetInput().(*AtomicValueInput_Watch); ok {
		return x.Watch
	}
	return nil
}

func (m *AtomicValueInput) GetEvents() *EventsInput {
	if x, ok := m.GetInput().(*AtomicValueInput_Events); ok {
		return x.Events
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AtomicValueInput) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AtomicValueInput_Get)(nil),
		(*AtomicValueInput_Set)(nil),
		(*AtomicValueInput_Update)(nil),
		(*AtomicValueInput_Delete)(nil),
		(*AtomicValueInput_Watch)(nil),
		(*AtomicValueInput_Events)(nil),
	}
}

type AtomicValueOutput struct {
	// Types that are valid to be assigned to Output:
	//	*AtomicValueOutput_Get
	//	*AtomicValueOutput_Set
	//	*AtomicValueOutput_Update
	//	*AtomicValueOutput_Delete
	//	*AtomicValueOutput_Watch
	//	*AtomicValueOutput_Events
	Output isAtomicValueOutput_Output `protobuf_oneof:"output"`
}

func (m *AtomicValueOutput) Reset()         { *m = AtomicValueOutput{} }
func (m *AtomicValueOutput) String() string { return proto.CompactTextString(m) }
func (*AtomicValueOutput) ProtoMessage()    {}
func (*AtomicValueOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_773e0cea356866c7, []int{2}
}
func (m *AtomicValueOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AtomicValueOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AtomicValueOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AtomicValueOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AtomicValueOutput.Merge(m, src)
}
func (m *AtomicValueOutput) XXX_Size() int {
	return m.Size()
}
func (m *AtomicValueOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_AtomicValueOutput.DiscardUnknown(m)
}

var xxx_messageInfo_AtomicValueOutput proto.InternalMessageInfo

type isAtomicValueOutput_Output interface {
	isAtomicValueOutput_Output()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AtomicValueOutput_Get struct {
	Get *GetOutput `protobuf:"bytes,1,opt,name=get,proto3,oneof" json:"get,omitempty"`
}
type AtomicValueOutput_Set struct {
	Set *SetOutput `protobuf:"bytes,2,opt,name=set,proto3,oneof" json:"set,omitempty"`
}
type AtomicValueOutput_Update struct {
	Update *UpdateOutput `protobuf:"bytes,3,opt,name=update,proto3,oneof" json:"update,omitempty"`
}
type AtomicValueOutput_Delete struct {
	Delete *DeleteOutput `protobuf:"bytes,4,opt,name=delete,proto3,oneof" json:"delete,omitempty"`
}
type AtomicValueOutput_Watch struct {
	Watch *WatchOutput `protobuf:"bytes,5,opt,name=watch,proto3,oneof" json:"watch,omitempty"`
}
type AtomicValueOutput_Events struct {
	Events *EventsOutput `protobuf:"bytes,6,opt,name=events,proto3,oneof" json:"events,omitempty"`
}

func (*AtomicValueOutput_Get) isAtomicValueOutput_Output()    {}
func (*AtomicValueOutput_Set) isAtomicValueOutput_Output()    {}
func (*AtomicValueOutput_Update) isAtomicValueOutput_Output() {}
func (*AtomicValueOutput_Delete) isAtomicValueOutput_Output() {}
func (*AtomicValueOutput_Watch) isAtomicValueOutput_Output()  {}
func (*AtomicValueOutput_Events) isAtomicValueOutput_Output() {}

func (m *AtomicValueOutput) GetOutput() isAtomicValueOutput_Output {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *AtomicValueOutput) GetGet() *GetOutput {
	if x, ok := m.GetOutput().(*AtomicValueOutput_Get); ok {
		return x.Get
	}
	return nil
}

func (m *AtomicValueOutput) GetSet() *SetOutput {
	if x, ok := m.GetOutput().(*AtomicValueOutput_Set); ok {
		return x.Set
	}
	return nil
}

func (m *AtomicValueOutput) GetUpdate() *UpdateOutput {
	if x, ok := m.GetOutput().(*AtomicValueOutput_Update); ok {
		return x.Update
	}
	return nil
}

func (m *AtomicValueOutput) GetDelete() *DeleteOutput {
	if x, ok := m.GetOutput().(*AtomicValueOutput_Delete); ok {
		return x.Delete
	}
	return nil
}

func (m *AtomicValueOutput) GetWatch() *WatchOutput {
	if x, ok := m.GetOutput().(*AtomicValueOutput_Watch); ok {
		return x.Watch
	}
	return nil
}

func (m *AtomicValueOutput) GetEvents() *EventsOutput {
	if x, ok := m.GetOutput().(*AtomicValueOutput_Events); ok {
		return x.Events
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AtomicValueOutput) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AtomicValueOutput_Get)(nil),
		(*AtomicValueOutput_Set)(nil),
		(*AtomicValueOutput_Update)(nil),
		(*AtomicValueOutput_Delete)(nil),
		(*AtomicValueOutput_Watch)(nil),
		(*AtomicValueOutput_Events)(nil),
	}
}

type GetInput struct {
}

func (m *GetInput) Reset()         { *m = GetInput{} }
func (m *GetInput) String() string { return proto.CompactTextString(m) }
func (*GetInput) ProtoMessage()    {}
func (*GetInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_773e0cea356866c7, []int{3}
}
func (m *GetInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetInput.Merge(m, src)
}
func (m *GetInput) XXX_Size() int {
	return m.Size()
}
func (m *GetInput) XXX_DiscardUnknown() {
	xxx_messageInfo_GetInput.DiscardUnknown(m)
}

var xxx_messageInfo_GetInput proto.InternalMessageInfo

type GetOutput struct {
	Value *Value `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *GetOutput) Reset()         { *m = GetOutput{} }
func (m *GetOutput) String() string { return proto.CompactTextString(m) }
func (*GetOutput) ProtoMessage()    {}
func (*GetOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_773e0cea356866c7, []int{4}
}
func (m *GetOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetOutput.Merge(m, src)
}
func (m *GetOutput) XXX_Size() int {
	return m.Size()
}
func (m *GetOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_GetOutput.DiscardUnknown(m)
}

var xxx_messageInfo_GetOutput proto.InternalMessageInfo

func (m *GetOutput) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

type SetInput struct {
	Value []byte         `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	TTL   *time.Duration `protobuf:"bytes,2,opt,name=ttl,proto3,stdduration" json:"ttl,omitempty"`
}

func (m *SetInput) Reset()         { *m = SetInput{} }
func (m *SetInput) String() string { return proto.CompactTextString(m) }
func (*SetInput) ProtoMessage()    {}
func (*SetInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_773e0cea356866c7, []int{5}
}
func (m *SetInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetInput.Merge(m, src)
}
func (m *SetInput) XXX_Size() int {
	return m.Size()
}
func (m *SetInput) XXX_DiscardUnknown() {
	xxx_messageInfo_SetInput.DiscardUnknown(m)
}

var xxx_messageInfo_SetInput proto.InternalMessageInfo

func (m *SetInput) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *SetInput) GetTTL() *time.Duration {
	if m != nil {
		return m.TTL
	}
	return nil
}

type SetOutput struct {
	Index github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index `protobuf:"varint,1,opt,name=index,proto3,casttype=github.com/atomix/multi-raft-storage/api/atomix/multiraft/v1.Index" json:"index,omitempty"`
}

func (m *SetOutput) Reset()         { *m = SetOutput{} }
func (m *SetOutput) String() string { return proto.CompactTextString(m) }
func (*SetOutput) ProtoMessage()    {}
func (*SetOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_773e0cea356866c7, []int{6}
}
func (m *SetOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetOutput.Merge(m, src)
}
func (m *SetOutput) XXX_Size() int {
	return m.Size()
}
func (m *SetOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_SetOutput.DiscardUnknown(m)
}

var xxx_messageInfo_SetOutput proto.InternalMessageInfo

func (m *SetOutput) GetIndex() github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index {
	if m != nil {
		return m.Index
	}
	return 0
}

type UpdateInput struct {
	Value     []byte                                                             `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	PrevIndex github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index `protobuf:"varint,2,opt,name=prev_index,json=prevIndex,proto3,casttype=github.com/atomix/multi-raft-storage/api/atomix/multiraft/v1.Index" json:"prev_index,omitempty"`
	TTL       *time.Duration                                                     `protobuf:"bytes,3,opt,name=ttl,proto3,stdduration" json:"ttl,omitempty"`
}

func (m *UpdateInput) Reset()         { *m = UpdateInput{} }
func (m *UpdateInput) String() string { return proto.CompactTextString(m) }
func (*UpdateInput) ProtoMessage()    {}
func (*UpdateInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_773e0cea356866c7, []int{7}
}
func (m *UpdateInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateInput.Merge(m, src)
}
func (m *UpdateInput) XXX_Size() int {
	return m.Size()
}
func (m *UpdateInput) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateInput.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateInput proto.InternalMessageInfo

func (m *UpdateInput) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *UpdateInput) GetPrevIndex() github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index {
	if m != nil {
		return m.PrevIndex
	}
	return 0
}

func (m *UpdateInput) GetTTL() *time.Duration {
	if m != nil {
		return m.TTL
	}
	return nil
}

type UpdateOutput struct {
	Index     github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index `protobuf:"varint,1,opt,name=index,proto3,casttype=github.com/atomix/multi-raft-storage/api/atomix/multiraft/v1.Index" json:"index,omitempty"`
	PrevValue Value                                                              `protobuf:"bytes,2,opt,name=prev_value,json=prevValue,proto3" json:"prev_value"`
}

func (m *UpdateOutput) Reset()         { *m = UpdateOutput{} }
func (m *UpdateOutput) String() string { return proto.CompactTextString(m) }
func (*UpdateOutput) ProtoMessage()    {}
func (*UpdateOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_773e0cea356866c7, []int{8}
}
func (m *UpdateOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateOutput.Merge(m, src)
}
func (m *UpdateOutput) XXX_Size() int {
	return m.Size()
}
func (m *UpdateOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateOutput.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateOutput proto.InternalMessageInfo

func (m *UpdateOutput) GetIndex() github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *UpdateOutput) GetPrevValue() Value {
	if m != nil {
		return m.PrevValue
	}
	return Value{}
}

type DeleteInput struct {
	PrevIndex github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index `protobuf:"varint,1,opt,name=prev_index,json=prevIndex,proto3,casttype=github.com/atomix/multi-raft-storage/api/atomix/multiraft/v1.Index" json:"prev_index,omitempty"`
}

func (m *DeleteInput) Reset()         { *m = DeleteInput{} }
func (m *DeleteInput) String() string { return proto.CompactTextString(m) }
func (*DeleteInput) ProtoMessage()    {}
func (*DeleteInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_773e0cea356866c7, []int{9}
}
func (m *DeleteInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteInput.Merge(m, src)
}
func (m *DeleteInput) XXX_Size() int {
	return m.Size()
}
func (m *DeleteInput) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteInput.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteInput proto.InternalMessageInfo

func (m *DeleteInput) GetPrevIndex() github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index {
	if m != nil {
		return m.PrevIndex
	}
	return 0
}

type DeleteOutput struct {
	Value Value `protobuf:"bytes,1,opt,name=value,proto3" json:"value"`
}

func (m *DeleteOutput) Reset()         { *m = DeleteOutput{} }
func (m *DeleteOutput) String() string { return proto.CompactTextString(m) }
func (*DeleteOutput) ProtoMessage()    {}
func (*DeleteOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_773e0cea356866c7, []int{10}
}
func (m *DeleteOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteOutput.Merge(m, src)
}
func (m *DeleteOutput) XXX_Size() int {
	return m.Size()
}
func (m *DeleteOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteOutput.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteOutput proto.InternalMessageInfo

func (m *DeleteOutput) GetValue() Value {
	if m != nil {
		return m.Value
	}
	return Value{}
}

type WatchInput struct {
}

func (m *WatchInput) Reset()         { *m = WatchInput{} }
func (m *WatchInput) String() string { return proto.CompactTextString(m) }
func (*WatchInput) ProtoMessage()    {}
func (*WatchInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_773e0cea356866c7, []int{11}
}
func (m *WatchInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatchInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatchInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatchInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatchInput.Merge(m, src)
}
func (m *WatchInput) XXX_Size() int {
	return m.Size()
}
func (m *WatchInput) XXX_DiscardUnknown() {
	xxx_messageInfo_WatchInput.DiscardUnknown(m)
}

var xxx_messageInfo_WatchInput proto.InternalMessageInfo

type WatchOutput struct {
	Value *Value `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *WatchOutput) Reset()         { *m = WatchOutput{} }
func (m *WatchOutput) String() string { return proto.CompactTextString(m) }
func (*WatchOutput) ProtoMessage()    {}
func (*WatchOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_773e0cea356866c7, []int{12}
}
func (m *WatchOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatchOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatchOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatchOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatchOutput.Merge(m, src)
}
func (m *WatchOutput) XXX_Size() int {
	return m.Size()
}
func (m *WatchOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_WatchOutput.DiscardUnknown(m)
}

var xxx_messageInfo_WatchOutput proto.InternalMessageInfo

func (m *WatchOutput) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

type EventsInput struct {
}

func (m *EventsInput) Reset()         { *m = EventsInput{} }
func (m *EventsInput) String() string { return proto.CompactTextString(m) }
func (*EventsInput) ProtoMessage()    {}
func (*EventsInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_773e0cea356866c7, []int{13}
}
func (m *EventsInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventsInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventsInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventsInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventsInput.Merge(m, src)
}
func (m *EventsInput) XXX_Size() int {
	return m.Size()
}
func (m *EventsInput) XXX_DiscardUnknown() {
	xxx_messageInfo_EventsInput.DiscardUnknown(m)
}

var xxx_messageInfo_EventsInput proto.InternalMessageInfo

type EventsOutput struct {
	Event Event `protobuf:"bytes,1,opt,name=event,proto3" json:"event"`
}

func (m *EventsOutput) Reset()         { *m = EventsOutput{} }
func (m *EventsOutput) String() string { return proto.CompactTextString(m) }
func (*EventsOutput) ProtoMessage()    {}
func (*EventsOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_773e0cea356866c7, []int{14}
}
func (m *EventsOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventsOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventsOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventsOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventsOutput.Merge(m, src)
}
func (m *EventsOutput) XXX_Size() int {
	return m.Size()
}
func (m *EventsOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_EventsOutput.DiscardUnknown(m)
}

var xxx_messageInfo_EventsOutput proto.InternalMessageInfo

func (m *EventsOutput) GetEvent() Event {
	if m != nil {
		return m.Event
	}
	return Event{}
}

type Value struct {
	Value []byte                                                             `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Index github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index `protobuf:"varint,2,opt,name=index,proto3,casttype=github.com/atomix/multi-raft-storage/api/atomix/multiraft/v1.Index" json:"index,omitempty"`
}

func (m *Value) Reset()         { *m = Value{} }
func (m *Value) String() string { return proto.CompactTextString(m) }
func (*Value) ProtoMessage()    {}
func (*Value) Descriptor() ([]byte, []int) {
	return fileDescriptor_773e0cea356866c7, []int{15}
}
func (m *Value) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Value) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Value.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Value) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Value.Merge(m, src)
}
func (m *Value) XXX_Size() int {
	return m.Size()
}
func (m *Value) XXX_DiscardUnknown() {
	xxx_messageInfo_Value.DiscardUnknown(m)
}

var xxx_messageInfo_Value proto.InternalMessageInfo

func (m *Value) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Value) GetIndex() github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index {
	if m != nil {
		return m.Index
	}
	return 0
}

type Event struct {
	// Types that are valid to be assigned to Event:
	//	*Event_Created_
	//	*Event_Updated_
	//	*Event_Deleted_
	Event isEvent_Event `protobuf_oneof:"event"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_773e0cea356866c7, []int{16}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

type isEvent_Event interface {
	isEvent_Event()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Event_Created_ struct {
	Created *Event_Created `protobuf:"bytes,1,opt,name=created,proto3,oneof" json:"created,omitempty"`
}
type Event_Updated_ struct {
	Updated *Event_Updated `protobuf:"bytes,2,opt,name=updated,proto3,oneof" json:"updated,omitempty"`
}
type Event_Deleted_ struct {
	Deleted *Event_Deleted `protobuf:"bytes,3,opt,name=deleted,proto3,oneof" json:"deleted,omitempty"`
}

func (*Event_Created_) isEvent_Event() {}
func (*Event_Updated_) isEvent_Event() {}
func (*Event_Deleted_) isEvent_Event() {}

func (m *Event) GetEvent() isEvent_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *Event) GetCreated() *Event_Created {
	if x, ok := m.GetEvent().(*Event_Created_); ok {
		return x.Created
	}
	return nil
}

func (m *Event) GetUpdated() *Event_Updated {
	if x, ok := m.GetEvent().(*Event_Updated_); ok {
		return x.Updated
	}
	return nil
}

func (m *Event) GetDeleted() *Event_Deleted {
	if x, ok := m.GetEvent().(*Event_Deleted_); ok {
		return x.Deleted
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Event) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Event_Created_)(nil),
		(*Event_Updated_)(nil),
		(*Event_Deleted_)(nil),
	}
}

type Event_Created struct {
	Value Value `protobuf:"bytes,1,opt,name=value,proto3" json:"value"`
}

func (m *Event_Created) Reset()         { *m = Event_Created{} }
func (m *Event_Created) String() string { return proto.CompactTextString(m) }
func (*Event_Created) ProtoMessage()    {}
func (*Event_Created) Descriptor() ([]byte, []int) {
	return fileDescriptor_773e0cea356866c7, []int{16, 0}
}
func (m *Event_Created) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event_Created) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event_Created.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event_Created) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event_Created.Merge(m, src)
}
func (m *Event_Created) XXX_Size() int {
	return m.Size()
}
func (m *Event_Created) XXX_DiscardUnknown() {
	xxx_messageInfo_Event_Created.DiscardUnknown(m)
}

var xxx_messageInfo_Event_Created proto.InternalMessageInfo

func (m *Event_Created) GetValue() Value {
	if m != nil {
		return m.Value
	}
	return Value{}
}

type Event_Updated struct {
	Value     Value `protobuf:"bytes,1,opt,name=value,proto3" json:"value"`
	PrevValue Value `protobuf:"bytes,2,opt,name=prev_value,json=prevValue,proto3" json:"prev_value"`
}

func (m *Event_Updated) Reset()         { *m = Event_Updated{} }
func (m *Event_Updated) String() string { return proto.CompactTextString(m) }
func (*Event_Updated) ProtoMessage()    {}
func (*Event_Updated) Descriptor() ([]byte, []int) {
	return fileDescriptor_773e0cea356866c7, []int{16, 1}
}
func (m *Event_Updated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event_Updated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event_Updated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event_Updated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event_Updated.Merge(m, src)
}
func (m *Event_Updated) XXX_Size() int {
	return m.Size()
}
func (m *Event_Updated) XXX_DiscardUnknown() {
	xxx_messageInfo_Event_Updated.DiscardUnknown(m)
}

var xxx_messageInfo_Event_Updated proto.InternalMessageInfo

func (m *Event_Updated) GetValue() Value {
	if m != nil {
		return m.Value
	}
	return Value{}
}

func (m *Event_Updated) GetPrevValue() Value {
	if m != nil {
		return m.PrevValue
	}
	return Value{}
}

type Event_Deleted struct {
	Value   Value `protobuf:"bytes,1,opt,name=value,proto3" json:"value"`
	Expired bool  `protobuf:"varint,2,opt,name=expired,proto3" json:"expired,omitempty"`
}

func (m *Event_Deleted) Reset()         { *m = Event_Deleted{} }
func (m *Event_Deleted) String() string { return proto.CompactTextString(m) }
func (*Event_Deleted) ProtoMessage()    {}
func (*Event_Deleted) Descriptor() ([]byte, []int) {
	return fileDescriptor_773e0cea356866c7, []int{16, 2}
}
func (m *Event_Deleted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event_Deleted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event_Deleted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event_Deleted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event_Deleted.Merge(m, src)
}
func (m *Event_Deleted) XXX_Size() int {
	return m.Size()
}
func (m *Event_Deleted) XXX_DiscardUnknown() {
	xxx_messageInfo_Event_Deleted.DiscardUnknown(m)
}

var xxx_messageInfo_Event_Deleted proto.InternalMessageInfo

func (m *Event_Deleted) GetValue() Value {
	if m != nil {
		return m.Value
	}
	return Value{}
}

func (m *Event_Deleted) GetExpired() bool {
	if m != nil {
		return m.Expired
	}
	return false
}

func init() {
	proto.RegisterType((*AtomicValueState)(nil), "atomix.multiraft.atomic.value.v1.AtomicValueState")
	proto.RegisterType((*AtomicValueInput)(nil), "atomix.multiraft.atomic.value.v1.AtomicValueInput")
	proto.RegisterType((*AtomicValueOutput)(nil), "atomix.multiraft.atomic.value.v1.AtomicValueOutput")
	proto.RegisterType((*GetInput)(nil), "atomix.multiraft.atomic.value.v1.GetInput")
	proto.RegisterType((*GetOutput)(nil), "atomix.multiraft.atomic.value.v1.GetOutput")
	proto.RegisterType((*SetInput)(nil), "atomix.multiraft.atomic.value.v1.SetInput")
	proto.RegisterType((*SetOutput)(nil), "atomix.multiraft.atomic.value.v1.SetOutput")
	proto.RegisterType((*UpdateInput)(nil), "atomix.multiraft.atomic.value.v1.UpdateInput")
	proto.RegisterType((*UpdateOutput)(nil), "atomix.multiraft.atomic.value.v1.UpdateOutput")
	proto.RegisterType((*DeleteInput)(nil), "atomix.multiraft.atomic.value.v1.DeleteInput")
	proto.RegisterType((*DeleteOutput)(nil), "atomix.multiraft.atomic.value.v1.DeleteOutput")
	proto.RegisterType((*WatchInput)(nil), "atomix.multiraft.atomic.value.v1.WatchInput")
	proto.RegisterType((*WatchOutput)(nil), "atomix.multiraft.atomic.value.v1.WatchOutput")
	proto.RegisterType((*EventsInput)(nil), "atomix.multiraft.atomic.value.v1.EventsInput")
	proto.RegisterType((*EventsOutput)(nil), "atomix.multiraft.atomic.value.v1.EventsOutput")
	proto.RegisterType((*Value)(nil), "atomix.multiraft.atomic.value.v1.Value")
	proto.RegisterType((*Event)(nil), "atomix.multiraft.atomic.value.v1.Event")
	proto.RegisterType((*Event_Created)(nil), "atomix.multiraft.atomic.value.v1.Event.Created")
	proto.RegisterType((*Event_Updated)(nil), "atomix.multiraft.atomic.value.v1.Event.Updated")
	proto.RegisterType((*Event_Deleted)(nil), "atomix.multiraft.atomic.value.v1.Event.Deleted")
}

func init() {
	proto.RegisterFile("atomix/multiraft/atomic/value/v1/fsm.proto", fileDescriptor_773e0cea356866c7)
}

var fileDescriptor_773e0cea356866c7 = []byte{
	// 803 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x3f, 0x6f, 0xd3, 0x5e,
	0x14, 0x8d, 0xf3, 0xbf, 0x37, 0xf9, 0x49, 0x3f, 0xac, 0x0e, 0x26, 0x83, 0x53, 0x79, 0x01, 0xb5,
	0xe4, 0x59, 0x85, 0x85, 0x05, 0x2a, 0xdc, 0x96, 0xa6, 0x50, 0x81, 0x94, 0x16, 0x90, 0x10, 0x12,
	0x72, 0xe3, 0x57, 0xd7, 0x52, 0x52, 0x5b, 0xce, 0x73, 0xa8, 0xc4, 0x47, 0x60, 0xe9, 0xc8, 0xc0,
	0x27, 0x41, 0x8c, 0x1d, 0x3a, 0x76, 0x64, 0x2a, 0x28, 0xfd, 0x16, 0x4c, 0xe8, 0xdd, 0xf7, 0xec,
	0xb8, 0xa9, 0xaa, 0xb8, 0x34, 0xdd, 0xdc, 0xd7, 0x7b, 0xce, 0x3b, 0xef, 0x9e, 0x7b, 0xae, 0x02,
	0x8b, 0x36, 0xf3, 0xfb, 0xde, 0xa1, 0xd9, 0x8f, 0x7a, 0xcc, 0x0b, 0xed, 0x3d, 0x66, 0xe2, 0x41,
	0xd7, 0x1c, 0xda, 0xbd, 0x88, 0x9a, 0xc3, 0x65, 0x73, 0x6f, 0xd0, 0x27, 0x41, 0xe8, 0x33, 0x5f,
	0x5d, 0x10, 0xb5, 0x24, 0xa9, 0x25, 0xa2, 0x96, 0x60, 0x2d, 0x19, 0x2e, 0x37, 0x74, 0xd7, 0xf7,
	0xdd, 0x1e, 0x35, 0xb1, 0x7e, 0x37, 0xda, 0x33, 0x9d, 0x28, 0xb4, 0x99, 0xe7, 0x1f, 0x08, 0x86,
	0x46, 0x73, 0xf2, 0xff, 0xcc, 0xeb, 0xd3, 0x01, 0xb3, 0xfb, 0x81, 0x2c, 0x98, 0x77, 0x7d, 0xd7,
	0xc7, 0x4f, 0x93, 0x7f, 0x89, 0x53, 0xe3, 0x8b, 0x02, 0xff, 0x3f, 0xc3, 0xab, 0xde, 0xf2, 0x9b,
	0xb6, 0x99, 0xcd, 0xa8, 0xfa, 0x04, 0x4a, 0x78, 0xaf, 0xa6, 0x2c, 0x28, 0xf7, 0x6b, 0x0f, 0xef,
	0x91, 0x69, 0xea, 0x08, 0x82, 0x3b, 0x02, 0xa5, 0x3e, 0x86, 0x32, 0x3d, 0x0c, 0xbc, 0x90, 0x6a,
	0x79, 0xc4, 0x37, 0x88, 0xd0, 0x46, 0x62, 0x6d, 0x64, 0x27, 0xd6, 0x66, 0x15, 0x8f, 0x7e, 0x35,
	0x95, 0x8e, 0xac, 0x37, 0x7e, 0x14, 0x2e, 0xa8, 0xd9, 0x3c, 0x08, 0x22, 0xa6, 0x3e, 0x85, 0x82,
	0x4b, 0x99, 0xd4, 0xb2, 0x38, 0x5d, 0xcb, 0x06, 0x65, 0x08, 0x6c, 0xe7, 0x3a, 0x1c, 0xc8, 0xf1,
	0x03, 0xca, 0xa4, 0x96, 0x0c, 0xf8, 0xed, 0x14, 0x7e, 0x40, 0x99, 0xba, 0x01, 0xe5, 0x28, 0x70,
	0x6c, 0x46, 0xb5, 0x02, 0x52, 0xb4, 0xa6, 0x53, 0xbc, 0xc1, 0xfa, 0x98, 0x45, 0xc2, 0x39, 0x91,
	0x43, 0x7b, 0x94, 0x51, 0xad, 0x98, 0x95, 0x68, 0x0d, 0xeb, 0x13, 0x22, 0x01, 0x57, 0xd7, 0xa0,
	0xf4, 0xc9, 0x66, 0xdd, 0x7d, 0xad, 0x84, 0x3c, 0x0f, 0xa6, 0xf3, 0xbc, 0xe3, 0xe5, 0x31, 0x8d,
	0x00, 0x73, 0x39, 0x74, 0x48, 0x0f, 0xd8, 0x40, 0x2b, 0x67, 0x95, 0xb3, 0x8e, 0xf5, 0x89, 0x1c,
	0x01, 0xb7, 0x2a, 0x50, 0xf2, 0xf8, 0x91, 0x71, 0x5c, 0x80, 0x3b, 0x29, 0xfb, 0x5e, 0x47, 0x8c,
	0xfb, 0xb7, 0x92, 0xf6, 0x6f, 0x29, 0x93, 0x7f, 0x02, 0x19, 0x1b, 0xb8, 0x92, 0x36, 0x70, 0x29,
	0x93, 0x81, 0x63, 0x02, 0xee, 0x60, 0x7b, 0xc2, 0x41, 0x92, 0xd5, 0xc1, 0x84, 0x26, 0xb6, 0xb0,
	0x3d, 0x61, 0x21, 0xc9, 0x6a, 0xe1, 0x98, 0x49, 0x7a, 0xb8, 0x7e, 0xd1, 0xc3, 0x56, 0x46, 0x0f,
	0x13, 0x1e, 0x69, 0x62, 0x7b, 0xc2, 0x44, 0x92, 0xd5, 0xc4, 0xb1, 0x20, 0xe9, 0x62, 0x15, 0xca,
	0x3e, 0x9e, 0x19, 0x00, 0xd5, 0x38, 0x43, 0xc6, 0x0b, 0x98, 0x4b, 0xfc, 0xb8, 0xe1, 0x5e, 0x30,
	0xde, 0x43, 0x35, 0xce, 0x96, 0x3a, 0x9f, 0xa6, 0xaa, 0x8f, 0x37, 0x47, 0x81, 0xb1, 0x9e, 0x74,
	0xfa, 0xee, 0xa5, 0xb5, 0xb1, 0x26, 0x57, 0x9e, 0x55, 0x1b, 0x9d, 0x35, 0x0b, 0x3b, 0x3b, 0x5b,
	0x5f, 0xf9, 0xf2, 0xe0, 0x10, 0xc3, 0x83, 0xb9, 0xc4, 0x76, 0xf5, 0x03, 0x1f, 0x48, 0x87, 0x1e,
	0x22, 0x79, 0xd1, 0x7a, 0xfe, 0xe7, 0xac, 0x69, 0xb9, 0x1e, 0xdb, 0x8f, 0x76, 0x49, 0xd7, 0xef,
	0x9b, 0xe9, 0xbd, 0xdc, 0xe2, 0xb2, 0x5b, 0x03, 0xe6, 0x87, 0xb6, 0x4b, 0x4d, 0x3b, 0xf0, 0xcc,
	0x4b, 0x5b, 0x7b, 0xb8, 0x4c, 0x36, 0x39, 0x5b, 0x47, 0x90, 0x1a, 0xc7, 0x0a, 0xd4, 0x52, 0x01,
	0xbf, 0xe2, 0x29, 0x14, 0x20, 0x08, 0xe9, 0xf0, 0xa3, 0x10, 0x92, 0x9f, 0xa9, 0x90, 0x39, 0xce,
	0x8c, 0x9f, 0x71, 0xc7, 0x0a, 0xd7, 0xef, 0xd8, 0x77, 0x05, 0xea, 0xe9, 0x29, 0xbf, 0xdd, 0xae,
	0xa9, 0x5b, 0xb2, 0x1f, 0xa2, 0x55, 0xf9, 0x6b, 0x0d, 0x90, 0x55, 0x3c, 0x39, 0x6b, 0xe6, 0xc4,
	0xb3, 0xf1, 0xc0, 0x60, 0x50, 0x4b, 0xad, 0xc6, 0x89, 0x66, 0x2b, 0xb7, 0xd4, 0x6c, 0x63, 0x1b,
	0xea, 0xe9, 0x34, 0xab, 0xab, 0xff, 0x96, 0x07, 0xf9, 0x1c, 0x99, 0x8a, 0x3a, 0xc0, 0x78, 0x3b,
	0x1b, 0x5b, 0x50, 0x4b, 0xe5, 0xfc, 0xa6, 0x89, 0xfb, 0x0f, 0x6a, 0xa9, 0x95, 0xcd, 0xf5, 0xa7,
	0xc3, 0xcf, 0xf5, 0x63, 0xf8, 0xb3, 0xb3, 0x23, 0x3c, 0xd6, 0x8f, 0x58, 0xe3, 0x33, 0x94, 0xf0,
	0xce, 0x2b, 0x72, 0x90, 0x4c, 0x55, 0xfe, 0x36, 0xb2, 0x78, 0x5a, 0x84, 0x12, 0x6a, 0x52, 0x5f,
	0x42, 0xa5, 0x1b, 0x52, 0x9b, 0x51, 0x47, 0xbe, 0xc6, 0xcc, 0xf8, 0x1a, 0xb2, 0x2a, 0x60, 0xed,
	0x5c, 0x27, 0x66, 0xe0, 0x64, 0x62, 0xe1, 0x3b, 0x72, 0x52, 0x33, 0x93, 0x89, 0x44, 0x21, 0x99,
	0x64, 0xe0, 0x64, 0x62, 0xe7, 0x3b, 0x32, 0xa6, 0x99, 0xc9, 0xc4, 0xb0, 0x21, 0x99, 0x64, 0x68,
	0xbc, 0x82, 0x8a, 0xd4, 0x3b, 0x93, 0xe9, 0x6b, 0x7c, 0x53, 0xa0, 0x22, 0x35, 0xcf, 0x84, 0x70,
	0xb6, 0x39, 0x6f, 0xec, 0x43, 0x45, 0x36, 0x61, 0x36, 0xea, 0x34, 0xa8, 0x88, 0x9f, 0x9a, 0xc2,
	0xd8, 0x6a, 0x27, 0xfe, 0x93, 0xff, 0x88, 0xc1, 0x79, 0xb6, 0xb4, 0x93, 0x91, 0xae, 0x9c, 0x8e,
	0x74, 0xe5, 0xf7, 0x48, 0x57, 0x8e, 0xce, 0xf5, 0xdc, 0xe9, 0xb9, 0x9e, 0xfb, 0x79, 0xae, 0xe7,
	0x76, 0xcb, 0xb8, 0x56, 0x1f, 0xfd, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x06, 0x23, 0x45, 0x72, 0xd9,
	0x0b, 0x00, 0x00,
}

func (m *AtomicValueState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AtomicValueState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicValueState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Expire != nil {
		n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Expire, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expire):])
		if err1 != nil {
			return 0, err1
		}
		i -= n1
		i = encodeVarintFsm(dAtA, i, uint64(n1))
		i--
		dAtA[i] = 0x12
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AtomicValueInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AtomicValueInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicValueInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Input != nil {
		{
			size := m.Input.Size()
			i -= size
			if _, err := m.Input.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AtomicValueInput_Get) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicValueInput_Get) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Get != nil {
		{
			size, err := m.Get.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AtomicValueInput_Set) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicValueInput_Set) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Set != nil {
		{
			size, err := m.Set.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AtomicValueInput_Update) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicValueInput_Update) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Update != nil {
		{
			size, err := m.Update.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AtomicValueInput_Delete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicValueInput_Delete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Delete != nil {
		{
			size, err := m.Delete.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AtomicValueInput_Watch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicValueInput_Watch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Watch != nil {
		{
			size, err := m.Watch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *AtomicValueInput_Events) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicValueInput_Events) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Events != nil {
		{
			size, err := m.Events.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *AtomicValueOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AtomicValueOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicValueOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Output != nil {
		{
			size := m.Output.Size()
			i -= size
			if _, err := m.Output.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AtomicValueOutput_Get) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicValueOutput_Get) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Get != nil {
		{
			size, err := m.Get.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AtomicValueOutput_Set) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicValueOutput_Set) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Set != nil {
		{
			size, err := m.Set.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AtomicValueOutput_Update) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicValueOutput_Update) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Update != nil {
		{
			size, err := m.Update.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AtomicValueOutput_Delete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicValueOutput_Delete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Delete != nil {
		{
			size, err := m.Delete.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AtomicValueOutput_Watch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicValueOutput_Watch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Watch != nil {
		{
			size, err := m.Watch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *AtomicValueOutput_Events) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicValueOutput_Events) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Events != nil {
		{
			size, err := m.Events.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *GetInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TTL != nil {
		n16, err16 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.TTL, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TTL):])
		if err16 != nil {
			return 0, err16
		}
		i -= n16
		i = encodeVarintFsm(dAtA, i, uint64(n16))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TTL != nil {
		n17, err17 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.TTL, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TTL):])
		if err17 != nil {
			return 0, err17
		}
		i -= n17
		i = encodeVarintFsm(dAtA, i, uint64(n17))
		i--
		dAtA[i] = 0x1a
	}
	if m.PrevIndex != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.PrevIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PrevValue.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFsm(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Index != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrevIndex != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.PrevIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFsm(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *WatchInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatchInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *WatchOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatchOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventsInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventsInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventsInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *EventsOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventsOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventsOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Event.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFsm(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Value) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		i = encodeVarintFsm(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintFsm(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Event != nil {
		{
			size := m.Event.Size()
			i -= size
			if _, err := m.Event.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Event_Created_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_Created_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Created != nil {
		{
			size, err := m.Created.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Event_Updated_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_Updated_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Updated != nil {
		{
			size, err := m.Updated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Event_Deleted_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_Deleted_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Deleted != nil {
		{
			size, err := m.Deleted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Event_Created) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event_Created) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_Created) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFsm(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Event_Updated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event_Updated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_Updated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PrevValue.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFsm(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFsm(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Event_Deleted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event_Deleted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_Deleted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Expired {
		i--
		if m.Expired {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFsm(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintFsm(dAtA []byte, offset int, v uint64) int {
	offset -= sovFsm(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AtomicValueState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	if m.Expire != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expire)
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}

func (m *AtomicValueInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Input != nil {
		n += m.Input.Size()
	}
	return n
}

func (m *AtomicValueInput_Get) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Get != nil {
		l = m.Get.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicValueInput_Set) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Set != nil {
		l = m.Set.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicValueInput_Update) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Update != nil {
		l = m.Update.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicValueInput_Delete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delete != nil {
		l = m.Delete.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicValueInput_Watch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Watch != nil {
		l = m.Watch.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicValueInput_Events) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Events != nil {
		l = m.Events.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicValueOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		n += m.Output.Size()
	}
	return n
}

func (m *AtomicValueOutput_Get) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Get != nil {
		l = m.Get.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicValueOutput_Set) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Set != nil {
		l = m.Set.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicValueOutput_Update) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Update != nil {
		l = m.Update.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicValueOutput_Delete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delete != nil {
		l = m.Delete.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicValueOutput_Watch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Watch != nil {
		l = m.Watch.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *AtomicValueOutput_Events) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Events != nil {
		l = m.Events.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *GetInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}

func (m *SetInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	if m.TTL != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TTL)
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}

func (m *SetOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovFsm(uint64(m.Index))
	}
	return n
}

func (m *UpdateInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	if m.PrevIndex != 0 {
		n += 1 + sovFsm(uint64(m.PrevIndex))
	}
	if m.TTL != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TTL)
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}

func (m *UpdateOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovFsm(uint64(m.Index))
	}
	l = m.PrevValue.Size()
	n += 1 + l + sovFsm(uint64(l))
	return n
}

func (m *DeleteInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrevIndex != 0 {
		n += 1 + sovFsm(uint64(m.PrevIndex))
	}
	return n
}

func (m *DeleteOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Value.Size()
	n += 1 + l + sovFsm(uint64(l))
	return n
}

func (m *WatchInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *WatchOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}

func (m *EventsInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *EventsOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Event.Size()
	n += 1 + l + sovFsm(uint64(l))
	return n
}

func (m *Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovFsm(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovFsm(uint64(m.Index))
	}
	return n
}

func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != nil {
		n += m.Event.Size()
	}
	return n
}

func (m *Event_Created_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Created != nil {
		l = m.Created.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *Event_Updated_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Updated != nil {
		l = m.Updated.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *Event_Deleted_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Deleted != nil {
		l = m.Deleted.Size()
		n += 1 + l + sovFsm(uint64(l))
	}
	return n
}
func (m *Event_Created) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Value.Size()
	n += 1 + l + sovFsm(uint64(l))
	return n
}

func (m *Event_Updated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Value.Size()
	n += 1 + l + sovFsm(uint64(l))
	l = m.PrevValue.Size()
	n += 1 + l + sovFsm(uint64(l))
	return n
}

func (m *Event_Deleted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Value.Size()
	n += 1 + l + sovFsm(uint64(l))
	if m.Expired {
		n += 2
	}
	return n
}

func sovFsm(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFsm(x uint64) (n int) {
	return sovFsm(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AtomicValueState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AtomicValueState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AtomicValueState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expire == nil {
				m.Expire = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Expire, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AtomicValueInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AtomicValueInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AtomicValueInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Get", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &AtomicValueInput_Get{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SetInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &AtomicValueInput_Set{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UpdateInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &AtomicValueInput_Update{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &AtomicValueInput_Delete{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Watch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WatchInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &AtomicValueInput_Watch{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EventsInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &AtomicValueInput_Events{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AtomicValueOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AtomicValueOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AtomicValueOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Get", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &AtomicValueOutput_Get{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SetOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &AtomicValueOutput_Set{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UpdateOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &AtomicValueOutput_Update{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &AtomicValueOutput_Delete{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Watch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WatchOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &AtomicValueOutput_Watch{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EventsOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &AtomicValueOutput_Events{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TTL == nil {
				m.TTL = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.TTL, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevIndex", wireType)
			}
			m.PrevIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevIndex |= github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TTL == nil {
				m.TTL = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.TTL, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrevValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevIndex", wireType)
			}
			m.PrevIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevIndex |= github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventsInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventsInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventsInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventsOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventsOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventsOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= github_com_atomix_multi_raft_storage_api_atomix_multiraft_v1.Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Event_Created{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &Event_Created_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Event_Updated{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &Event_Updated_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deleted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Event_Deleted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &Event_Deleted_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event_Created) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Created: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Created: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event_Updated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Updated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Updated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrevValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event_Deleted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deleted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deleted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expired", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Expired = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFsm(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFsm
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFsm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFsm
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFsm
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFsm
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFsm        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFsm          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFsm = fmt.Errorf("proto: unexpected end of group")
)
