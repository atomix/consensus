// Code generated by MockGen. DO NOT EDIT.
// Source: statemachine (interfaces: Context,SessionManager,SessionManagerContext,OpenSessionProposal,KeepAliveProposal,CloseSessionProposal,SessionProposal,SessionQuery,Scheduler,Timer)

// Package statemachine is a generated GoMock package.
package statemachine

import (
	v1 "github.com/atomix/multi-raft-storage/api/atomix/multiraft/v1"
	"github.com/atomix/multi-raft-storage/node/pkg/statemachine/snapshot"
	logging "github.com/atomix/runtime/sdk/pkg/logging"
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
	time "time"
)

// MockContext is a mock of Context interface.
type MockContext struct {
	ctrl     *gomock.Controller
	recorder *MockContextMockRecorder
}

// MockContextMockRecorder is the mock recorder for MockContext.
type MockContextMockRecorder struct {
	mock *MockContext
}

// NewMockContext creates a new mock instance.
func NewMockContext(ctrl *gomock.Controller) *MockContext {
	mock := &MockContext{ctrl: ctrl}
	mock.recorder = &MockContextMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockContext) EXPECT() *MockContextMockRecorder {
	return m.recorder
}

// Index mocks base method.
func (m *MockContext) Index() Index {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Index")
	ret0, _ := ret[0].(Index)
	return ret0
}

// Index indicates an expected call of Index.
func (mr *MockContextMockRecorder) Index() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Index", reflect.TypeOf((*MockContext)(nil).Index))
}

// MockSessionManager is a mock of SessionManager interface.
type MockSessionManager struct {
	ctrl     *gomock.Controller
	recorder *MockSessionManagerMockRecorder
}

// MockSessionManagerMockRecorder is the mock recorder for MockSessionManager.
type MockSessionManagerMockRecorder struct {
	mock *MockSessionManager
}

// NewMockSessionManager creates a new mock instance.
func NewMockSessionManager(ctrl *gomock.Controller) *MockSessionManager {
	mock := &MockSessionManager{ctrl: ctrl}
	mock.recorder = &MockSessionManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSessionManager) EXPECT() *MockSessionManagerMockRecorder {
	return m.recorder
}

// CloseSession mocks base method.
func (m *MockSessionManager) CloseSession(arg0 CloseSessionProposal) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "CloseSession", arg0)
}

// CloseSession indicates an expected call of CloseSession.
func (mr *MockSessionManagerMockRecorder) CloseSession(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloseSession", reflect.TypeOf((*MockSessionManager)(nil).CloseSession), arg0)
}

// KeepAlive mocks base method.
func (m *MockSessionManager) KeepAlive(arg0 KeepAliveProposal) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "KeepAlive", arg0)
}

// KeepAlive indicates an expected call of KeepAlive.
func (mr *MockSessionManagerMockRecorder) KeepAlive(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "KeepAlive", reflect.TypeOf((*MockSessionManager)(nil).KeepAlive), arg0)
}

// OpenSession mocks base method.
func (m *MockSessionManager) OpenSession(arg0 OpenSessionProposal) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "OpenSession", arg0)
}

// OpenSession indicates an expected call of OpenSession.
func (mr *MockSessionManagerMockRecorder) OpenSession(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OpenSession", reflect.TypeOf((*MockSessionManager)(nil).OpenSession), arg0)
}

// Propose mocks base method.
func (m *MockSessionManager) Propose(arg0 SessionProposal) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Propose", arg0)
}

// Propose indicates an expected call of Propose.
func (mr *MockSessionManagerMockRecorder) Propose(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Propose", reflect.TypeOf((*MockSessionManager)(nil).Propose), arg0)
}

// Query mocks base method.
func (m *MockSessionManager) Query(arg0 SessionQuery) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Query", arg0)
}

// Query indicates an expected call of Query.
func (mr *MockSessionManagerMockRecorder) Query(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockSessionManager)(nil).Query), arg0)
}

// Recover mocks base method.
func (m *MockSessionManager) Recover(arg0 *snapshot.Reader) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Recover", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Recover indicates an expected call of Recover.
func (mr *MockSessionManagerMockRecorder) Recover(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Recover", reflect.TypeOf((*MockSessionManager)(nil).Recover), arg0)
}

// Snapshot mocks base method.
func (m *MockSessionManager) Snapshot(arg0 *snapshot.Writer) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Snapshot", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Snapshot indicates an expected call of Snapshot.
func (mr *MockSessionManagerMockRecorder) Snapshot(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Snapshot", reflect.TypeOf((*MockSessionManager)(nil).Snapshot), arg0)
}

// MockSessionManagerContext is a mock of SessionManagerContext interface.
type MockSessionManagerContext struct {
	ctrl     *gomock.Controller
	recorder *MockSessionManagerContextMockRecorder
}

// MockSessionManagerContextMockRecorder is the mock recorder for MockSessionManagerContext.
type MockSessionManagerContextMockRecorder struct {
	mock *MockSessionManagerContext
}

// NewMockSessionManagerContext creates a new mock instance.
func NewMockSessionManagerContext(ctrl *gomock.Controller) *MockSessionManagerContext {
	mock := &MockSessionManagerContext{ctrl: ctrl}
	mock.recorder = &MockSessionManagerContextMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSessionManagerContext) EXPECT() *MockSessionManagerContextMockRecorder {
	return m.recorder
}

// Index mocks base method.
func (m *MockSessionManagerContext) Index() Index {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Index")
	ret0, _ := ret[0].(Index)
	return ret0
}

// Index indicates an expected call of Index.
func (mr *MockSessionManagerContextMockRecorder) Index() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Index", reflect.TypeOf((*MockSessionManagerContext)(nil).Index))
}

// Log mocks base method.
func (m *MockSessionManagerContext) Log() logging.Logger {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Log")
	ret0, _ := ret[0].(logging.Logger)
	return ret0
}

// Log indicates an expected call of Log.
func (mr *MockSessionManagerContextMockRecorder) Log() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Log", reflect.TypeOf((*MockSessionManagerContext)(nil).Log))
}

// Scheduler mocks base method.
func (m *MockSessionManagerContext) Scheduler() Scheduler {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Scheduler")
	ret0, _ := ret[0].(Scheduler)
	return ret0
}

// Scheduler indicates an expected call of Scheduler.
func (mr *MockSessionManagerContextMockRecorder) Scheduler() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scheduler", reflect.TypeOf((*MockSessionManagerContext)(nil).Scheduler))
}

// Time mocks base method.
func (m *MockSessionManagerContext) Time() time.Time {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Time")
	ret0, _ := ret[0].(time.Time)
	return ret0
}

// Time indicates an expected call of Time.
func (mr *MockSessionManagerContextMockRecorder) Time() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Time", reflect.TypeOf((*MockSessionManagerContext)(nil).Time))
}

// MockOpenSessionProposal is a mock of OpenSessionProposal interface.
type MockOpenSessionProposal struct {
	ctrl     *gomock.Controller
	recorder *MockOpenSessionProposalMockRecorder
}

// MockOpenSessionProposalMockRecorder is the mock recorder for MockOpenSessionProposal.
type MockOpenSessionProposalMockRecorder struct {
	mock *MockOpenSessionProposal
}

// NewMockOpenSessionProposal creates a new mock instance.
func NewMockOpenSessionProposal(ctrl *gomock.Controller) *MockOpenSessionProposal {
	mock := &MockOpenSessionProposal{ctrl: ctrl}
	mock.recorder = &MockOpenSessionProposalMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOpenSessionProposal) EXPECT() *MockOpenSessionProposalMockRecorder {
	return m.recorder
}

// Cancel mocks base method.
func (m *MockOpenSessionProposal) Cancel() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Cancel")
}

// Cancel indicates an expected call of Cancel.
func (mr *MockOpenSessionProposalMockRecorder) Cancel() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cancel", reflect.TypeOf((*MockOpenSessionProposal)(nil).Cancel))
}

// Close mocks base method.
func (m *MockOpenSessionProposal) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockOpenSessionProposalMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockOpenSessionProposal)(nil).Close))
}

// Error mocks base method.
func (m *MockOpenSessionProposal) Error(arg0 error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Error", arg0)
}

// Error indicates an expected call of Error.
func (mr *MockOpenSessionProposalMockRecorder) Error(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockOpenSessionProposal)(nil).Error), arg0)
}

// ID mocks base method.
func (m *MockOpenSessionProposal) ID() ProposalID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(ProposalID)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockOpenSessionProposalMockRecorder) ID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockOpenSessionProposal)(nil).ID))
}

// Input mocks base method.
func (m *MockOpenSessionProposal) Input() *v1.OpenSessionInput {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Input")
	ret0, _ := ret[0].(*v1.OpenSessionInput)
	return ret0
}

// Input indicates an expected call of Input.
func (mr *MockOpenSessionProposalMockRecorder) Input() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Input", reflect.TypeOf((*MockOpenSessionProposal)(nil).Input))
}

// Log mocks base method.
func (m *MockOpenSessionProposal) Log() logging.Logger {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Log")
	ret0, _ := ret[0].(logging.Logger)
	return ret0
}

// Log indicates an expected call of Log.
func (mr *MockOpenSessionProposalMockRecorder) Log() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Log", reflect.TypeOf((*MockOpenSessionProposal)(nil).Log))
}

// Output mocks base method.
func (m *MockOpenSessionProposal) Output(arg0 *v1.OpenSessionOutput) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Output", arg0)
}

// Output indicates an expected call of Output.
func (mr *MockOpenSessionProposalMockRecorder) Output(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Output", reflect.TypeOf((*MockOpenSessionProposal)(nil).Output), arg0)
}

// MockKeepAliveProposal is a mock of KeepAliveProposal interface.
type MockKeepAliveProposal struct {
	ctrl     *gomock.Controller
	recorder *MockKeepAliveProposalMockRecorder
}

// MockKeepAliveProposalMockRecorder is the mock recorder for MockKeepAliveProposal.
type MockKeepAliveProposalMockRecorder struct {
	mock *MockKeepAliveProposal
}

// NewMockKeepAliveProposal creates a new mock instance.
func NewMockKeepAliveProposal(ctrl *gomock.Controller) *MockKeepAliveProposal {
	mock := &MockKeepAliveProposal{ctrl: ctrl}
	mock.recorder = &MockKeepAliveProposalMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockKeepAliveProposal) EXPECT() *MockKeepAliveProposalMockRecorder {
	return m.recorder
}

// Cancel mocks base method.
func (m *MockKeepAliveProposal) Cancel() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Cancel")
}

// Cancel indicates an expected call of Cancel.
func (mr *MockKeepAliveProposalMockRecorder) Cancel() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cancel", reflect.TypeOf((*MockKeepAliveProposal)(nil).Cancel))
}

// Close mocks base method.
func (m *MockKeepAliveProposal) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockKeepAliveProposalMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockKeepAliveProposal)(nil).Close))
}

// Error mocks base method.
func (m *MockKeepAliveProposal) Error(arg0 error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Error", arg0)
}

// Error indicates an expected call of Error.
func (mr *MockKeepAliveProposalMockRecorder) Error(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockKeepAliveProposal)(nil).Error), arg0)
}

// ID mocks base method.
func (m *MockKeepAliveProposal) ID() ProposalID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(ProposalID)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockKeepAliveProposalMockRecorder) ID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockKeepAliveProposal)(nil).ID))
}

// Input mocks base method.
func (m *MockKeepAliveProposal) Input() *v1.KeepAliveInput {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Input")
	ret0, _ := ret[0].(*v1.KeepAliveInput)
	return ret0
}

// Input indicates an expected call of Input.
func (mr *MockKeepAliveProposalMockRecorder) Input() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Input", reflect.TypeOf((*MockKeepAliveProposal)(nil).Input))
}

// Log mocks base method.
func (m *MockKeepAliveProposal) Log() logging.Logger {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Log")
	ret0, _ := ret[0].(logging.Logger)
	return ret0
}

// Log indicates an expected call of Log.
func (mr *MockKeepAliveProposalMockRecorder) Log() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Log", reflect.TypeOf((*MockKeepAliveProposal)(nil).Log))
}

// Output mocks base method.
func (m *MockKeepAliveProposal) Output(arg0 *v1.KeepAliveOutput) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Output", arg0)
}

// Output indicates an expected call of Output.
func (mr *MockKeepAliveProposalMockRecorder) Output(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Output", reflect.TypeOf((*MockKeepAliveProposal)(nil).Output), arg0)
}

// MockCloseSessionProposal is a mock of CloseSessionProposal interface.
type MockCloseSessionProposal struct {
	ctrl     *gomock.Controller
	recorder *MockCloseSessionProposalMockRecorder
}

// MockCloseSessionProposalMockRecorder is the mock recorder for MockCloseSessionProposal.
type MockCloseSessionProposalMockRecorder struct {
	mock *MockCloseSessionProposal
}

// NewMockCloseSessionProposal creates a new mock instance.
func NewMockCloseSessionProposal(ctrl *gomock.Controller) *MockCloseSessionProposal {
	mock := &MockCloseSessionProposal{ctrl: ctrl}
	mock.recorder = &MockCloseSessionProposalMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCloseSessionProposal) EXPECT() *MockCloseSessionProposalMockRecorder {
	return m.recorder
}

// Cancel mocks base method.
func (m *MockCloseSessionProposal) Cancel() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Cancel")
}

// Cancel indicates an expected call of Cancel.
func (mr *MockCloseSessionProposalMockRecorder) Cancel() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cancel", reflect.TypeOf((*MockCloseSessionProposal)(nil).Cancel))
}

// Close mocks base method.
func (m *MockCloseSessionProposal) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockCloseSessionProposalMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockCloseSessionProposal)(nil).Close))
}

// Error mocks base method.
func (m *MockCloseSessionProposal) Error(arg0 error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Error", arg0)
}

// Error indicates an expected call of Error.
func (mr *MockCloseSessionProposalMockRecorder) Error(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockCloseSessionProposal)(nil).Error), arg0)
}

// ID mocks base method.
func (m *MockCloseSessionProposal) ID() ProposalID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(ProposalID)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockCloseSessionProposalMockRecorder) ID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockCloseSessionProposal)(nil).ID))
}

// Input mocks base method.
func (m *MockCloseSessionProposal) Input() *v1.CloseSessionInput {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Input")
	ret0, _ := ret[0].(*v1.CloseSessionInput)
	return ret0
}

// Input indicates an expected call of Input.
func (mr *MockCloseSessionProposalMockRecorder) Input() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Input", reflect.TypeOf((*MockCloseSessionProposal)(nil).Input))
}

// Log mocks base method.
func (m *MockCloseSessionProposal) Log() logging.Logger {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Log")
	ret0, _ := ret[0].(logging.Logger)
	return ret0
}

// Log indicates an expected call of Log.
func (mr *MockCloseSessionProposalMockRecorder) Log() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Log", reflect.TypeOf((*MockCloseSessionProposal)(nil).Log))
}

// Output mocks base method.
func (m *MockCloseSessionProposal) Output(arg0 *v1.CloseSessionOutput) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Output", arg0)
}

// Output indicates an expected call of Output.
func (mr *MockCloseSessionProposalMockRecorder) Output(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Output", reflect.TypeOf((*MockCloseSessionProposal)(nil).Output), arg0)
}

// MockSessionProposal is a mock of SessionProposal interface.
type MockSessionProposal struct {
	ctrl     *gomock.Controller
	recorder *MockSessionProposalMockRecorder
}

// MockSessionProposalMockRecorder is the mock recorder for MockSessionProposal.
type MockSessionProposalMockRecorder struct {
	mock *MockSessionProposal
}

// NewMockSessionProposal creates a new mock instance.
func NewMockSessionProposal(ctrl *gomock.Controller) *MockSessionProposal {
	mock := &MockSessionProposal{ctrl: ctrl}
	mock.recorder = &MockSessionProposalMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSessionProposal) EXPECT() *MockSessionProposalMockRecorder {
	return m.recorder
}

// Cancel mocks base method.
func (m *MockSessionProposal) Cancel() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Cancel")
}

// Cancel indicates an expected call of Cancel.
func (mr *MockSessionProposalMockRecorder) Cancel() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cancel", reflect.TypeOf((*MockSessionProposal)(nil).Cancel))
}

// Close mocks base method.
func (m *MockSessionProposal) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockSessionProposalMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockSessionProposal)(nil).Close))
}

// Error mocks base method.
func (m *MockSessionProposal) Error(arg0 error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Error", arg0)
}

// Error indicates an expected call of Error.
func (mr *MockSessionProposalMockRecorder) Error(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockSessionProposal)(nil).Error), arg0)
}

// ID mocks base method.
func (m *MockSessionProposal) ID() ProposalID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(ProposalID)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockSessionProposalMockRecorder) ID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockSessionProposal)(nil).ID))
}

// Input mocks base method.
func (m *MockSessionProposal) Input() *v1.SessionProposalInput {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Input")
	ret0, _ := ret[0].(*v1.SessionProposalInput)
	return ret0
}

// Input indicates an expected call of Input.
func (mr *MockSessionProposalMockRecorder) Input() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Input", reflect.TypeOf((*MockSessionProposal)(nil).Input))
}

// Log mocks base method.
func (m *MockSessionProposal) Log() logging.Logger {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Log")
	ret0, _ := ret[0].(logging.Logger)
	return ret0
}

// Log indicates an expected call of Log.
func (mr *MockSessionProposalMockRecorder) Log() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Log", reflect.TypeOf((*MockSessionProposal)(nil).Log))
}

// Output mocks base method.
func (m *MockSessionProposal) Output(arg0 *v1.SessionProposalOutput) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Output", arg0)
}

// Output indicates an expected call of Output.
func (mr *MockSessionProposalMockRecorder) Output(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Output", reflect.TypeOf((*MockSessionProposal)(nil).Output), arg0)
}

// MockSessionQuery is a mock of SessionQuery interface.
type MockSessionQuery struct {
	ctrl     *gomock.Controller
	recorder *MockSessionQueryMockRecorder
}

// MockSessionQueryMockRecorder is the mock recorder for MockSessionQuery.
type MockSessionQueryMockRecorder struct {
	mock *MockSessionQuery
}

// NewMockSessionQuery creates a new mock instance.
func NewMockSessionQuery(ctrl *gomock.Controller) *MockSessionQuery {
	mock := &MockSessionQuery{ctrl: ctrl}
	mock.recorder = &MockSessionQueryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSessionQuery) EXPECT() *MockSessionQueryMockRecorder {
	return m.recorder
}

// Cancel mocks base method.
func (m *MockSessionQuery) Cancel() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Cancel")
}

// Cancel indicates an expected call of Cancel.
func (mr *MockSessionQueryMockRecorder) Cancel() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cancel", reflect.TypeOf((*MockSessionQuery)(nil).Cancel))
}

// Close mocks base method.
func (m *MockSessionQuery) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockSessionQueryMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockSessionQuery)(nil).Close))
}

// Error mocks base method.
func (m *MockSessionQuery) Error(arg0 error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Error", arg0)
}

// Error indicates an expected call of Error.
func (mr *MockSessionQueryMockRecorder) Error(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockSessionQuery)(nil).Error), arg0)
}

// ID mocks base method.
func (m *MockSessionQuery) ID() QueryID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(QueryID)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockSessionQueryMockRecorder) ID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockSessionQuery)(nil).ID))
}

// Input mocks base method.
func (m *MockSessionQuery) Input() *v1.SessionQueryInput {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Input")
	ret0, _ := ret[0].(*v1.SessionQueryInput)
	return ret0
}

// Input indicates an expected call of Input.
func (mr *MockSessionQueryMockRecorder) Input() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Input", reflect.TypeOf((*MockSessionQuery)(nil).Input))
}

// Log mocks base method.
func (m *MockSessionQuery) Log() logging.Logger {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Log")
	ret0, _ := ret[0].(logging.Logger)
	return ret0
}

// Log indicates an expected call of Log.
func (mr *MockSessionQueryMockRecorder) Log() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Log", reflect.TypeOf((*MockSessionQuery)(nil).Log))
}

// Output mocks base method.
func (m *MockSessionQuery) Output(arg0 *v1.SessionQueryOutput) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Output", arg0)
}

// Output indicates an expected call of Output.
func (mr *MockSessionQueryMockRecorder) Output(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Output", reflect.TypeOf((*MockSessionQuery)(nil).Output), arg0)
}

// MockScheduler is a mock of Scheduler interface.
type MockScheduler struct {
	ctrl     *gomock.Controller
	recorder *MockSchedulerMockRecorder
}

// MockSchedulerMockRecorder is the mock recorder for MockScheduler.
type MockSchedulerMockRecorder struct {
	mock *MockScheduler
}

// NewMockScheduler creates a new mock instance.
func NewMockScheduler(ctrl *gomock.Controller) *MockScheduler {
	mock := &MockScheduler{ctrl: ctrl}
	mock.recorder = &MockSchedulerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockScheduler) EXPECT() *MockSchedulerMockRecorder {
	return m.recorder
}

// Await mocks base method.
func (m *MockScheduler) Await(arg0 Index, arg1 func()) CancelFunc {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Await", arg0, arg1)
	ret0, _ := ret[0].(CancelFunc)
	return ret0
}

// Await indicates an expected call of Await.
func (mr *MockSchedulerMockRecorder) Await(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Await", reflect.TypeOf((*MockScheduler)(nil).Await), arg0, arg1)
}

// Delay mocks base method.
func (m *MockScheduler) Delay(arg0 time.Duration, arg1 func()) CancelFunc {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delay", arg0, arg1)
	ret0, _ := ret[0].(CancelFunc)
	return ret0
}

// Delay indicates an expected call of Delay.
func (mr *MockSchedulerMockRecorder) Delay(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delay", reflect.TypeOf((*MockScheduler)(nil).Delay), arg0, arg1)
}

// Schedule mocks base method.
func (m *MockScheduler) Schedule(arg0 time.Time, arg1 func()) CancelFunc {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Schedule", arg0, arg1)
	ret0, _ := ret[0].(CancelFunc)
	return ret0
}

// Schedule indicates an expected call of Schedule.
func (mr *MockSchedulerMockRecorder) Schedule(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Schedule", reflect.TypeOf((*MockScheduler)(nil).Schedule), arg0, arg1)
}

// Time mocks base method.
func (m *MockScheduler) Time() time.Time {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Time")
	ret0, _ := ret[0].(time.Time)
	return ret0
}

// Time indicates an expected call of Time.
func (mr *MockSchedulerMockRecorder) Time() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Time", reflect.TypeOf((*MockScheduler)(nil).Time))
}
